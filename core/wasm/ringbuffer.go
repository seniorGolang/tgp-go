//go:build wasip1

// GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.

package wasm

import (
	"encoding/binary"
	"errors"
	"io"

	"tgp/core/i18n"
)

const (
	// RingBufferHeaderSize размер заголовка кольцевого буфера в байтах.
	RingBufferHeaderSize = 20

	// RingBufferOffset смещение для области данных.
	RingBufferOffset = RingBufferHeaderSize
)

// RingBufferHeader представляет заголовок кольцевого буфера в WASM памяти.
type RingBufferHeader struct {
	BufferSize uint32
	DataSize   uint32
	ReadIndex  uint32
	WriteIndex uint32
	Closed     uint32
}

// ReadRingBufferHeader читает заголовок кольцевого буфера из WASM памяти.
// Используется только при создании буфера или когда нужен полный заголовок.
// Для операций чтения/записи используйте ReadIndicesAndClosed.
func ReadRingBufferHeader(bufferPtr uint32) (header RingBufferHeader, err error) {

	// Читаем заголовок из памяти
	headerBytes := PtrToByte(bufferPtr, RingBufferHeaderSize)
	if len(headerBytes) < RingBufferHeaderSize {
		return header, io.ErrUnexpectedEOF
	}

	header.BufferSize = binary.LittleEndian.Uint32(headerBytes[0:4])
	header.DataSize = binary.LittleEndian.Uint32(headerBytes[4:8])
	header.ReadIndex = binary.LittleEndian.Uint32(headerBytes[8:12])
	header.WriteIndex = binary.LittleEndian.Uint32(headerBytes[12:16])
	header.Closed = binary.LittleEndian.Uint32(headerBytes[16:20])

	return header, nil
}

// ReadIndicesAndClosed читает только индексы и флаг закрытия (12 байт) из заголовка кольцевого буфера.
// Оптимизированная версия ReadRingBufferHeader для операций чтения/записи.
// Читает только: ReadIndex (4 байта) + WriteIndex (4 байта) + Closed (4 байта).
func ReadIndicesAndClosed(bufferPtr uint32) (readIdx uint32, writeIdx uint32, closed uint32, err error) {

	if bufferPtr == 0 {
		return 0, 0, 0, errors.New(i18n.Msg("invalid buffer pointer: zero"))
	}

	// Читаем только 12 байт: ReadIndex (8-11) + WriteIndex (12-15) + Closed (16-19)
	indicesBytes := PtrToByte(bufferPtr+8, 12)
	if len(indicesBytes) < 12 {
		return 0, 0, 0, io.ErrUnexpectedEOF
	}

	readIdx = binary.LittleEndian.Uint32(indicesBytes[0:4])
	writeIdx = binary.LittleEndian.Uint32(indicesBytes[4:8])
	closed = binary.LittleEndian.Uint32(indicesBytes[8:12])

	return readIdx, writeIdx, closed, nil
}

// ReadClosedFlag читает только флаг закрытия (4 байта) из заголовка кольцевого буфера.
// Используется для проверки состояния буфера без чтения всего заголовка.
func ReadClosedFlag(bufferPtr uint32) (closed uint32, err error) {

	if bufferPtr == 0 {
		return 0, errors.New(i18n.Msg("invalid buffer pointer: zero"))
	}

	// Читаем только 4 байта: Closed (16-19)
	closedBytes := PtrToByte(bufferPtr+16, 4)
	if len(closedBytes) < 4 {
		return 0, io.ErrUnexpectedEOF
	}

	closed = binary.LittleEndian.Uint32(closedBytes[0:4])
	return closed, nil
}

// AvailableRead вычисляет количество доступных байт для чтения.
func AvailableRead(readIdx uint32, writeIdx uint32, dataSize uint32) (available uint32) {

	if writeIdx >= readIdx {
		return writeIdx - readIdx
	}

	return dataSize - readIdx + writeIdx
}

// AvailableWrite вычисляет количество доступного места для записи.
func AvailableWrite(readIdx uint32, writeIdx uint32, dataSize uint32) (available uint32) {

	if writeIdx >= readIdx {
		// Обычный случай: writeIdx >= readIdx
		available = dataSize - (writeIdx - readIdx)
		if available > 0 {
			available-- // Оставляем один байт для различения полного/пустого буфера
		}
	} else {
		// Wrap-around: writeIdx < readIdx
		available = readIdx - writeIdx - 1
	}

	return available
}

// UpdateRingBufferReadIndex обновляет индекс чтения в WASM памяти.
func UpdateRingBufferReadIndex(bufferPtr uint32, readIndex uint32) (err error) {

	readIndexPtr := bufferPtr + 8 // Смещение для ReadIndex

	// Записываем индекс в память
	indexBytes := make([]byte, 4)
	binary.LittleEndian.PutUint32(indexBytes, readIndex)

	// Копируем в WASM память
	ByteToPtr(indexBytes, readIndexPtr)

	return nil
}

// UpdateRingBufferWriteIndex обновляет индекс записи в WASM памяти.
func UpdateRingBufferWriteIndex(bufferPtr uint32, writeIndex uint32) (err error) {

	writeIndexPtr := bufferPtr + 12 // Смещение для WriteIndex

	// Записываем индекс в память
	indexBytes := make([]byte, 4)
	binary.LittleEndian.PutUint32(indexBytes, writeIndex)

	// Копируем в WASM память
	ByteToPtr(indexBytes, writeIndexPtr)

	return nil
}

// ReadFromRingBuffer читает данные из кольцевого буфера в WASM памяти.
// dataSize - кэшированный размер области данных (константа для буфера).
func ReadFromRingBuffer(bufferPtr uint32, dataSize uint32, data []byte) (read int, err error) {

	if len(data) == 0 {
		return 0, nil
	}

	// Читаем только индексы и флаг закрытия (12 байт вместо 20)
	var readIdx, writeIdx, closed uint32
	if readIdx, writeIdx, closed, err = ReadIndicesAndClosed(bufferPtr); err != nil {
		return 0, err
	}

	if closed != 0 {
		return 0, io.EOF
	}

	// Вычисляем доступные данные, используя кэшированный dataSize
	available := AvailableRead(readIdx, writeIdx, dataSize)
	if available == 0 {
		return 0, nil // Буфер пуст
	}

	// Ограничиваем размер данных доступными данными
	// Проверяем переполнение при конвертации int -> uint32
	dataLen := len(data)
	if dataLen < 0 || dataLen > int(^uint32(0)) {
		return 0, errors.New(i18n.Msg("data length out of range"))
	}
	toRead := uint32(dataLen)
	if toRead > available {
		toRead = available
	}

	dataOffset := bufferPtr + RingBufferOffset

	// Читаем данные с учетом wrap-around
	var readData []byte
	if readIdx+toRead <= dataSize {
		// Обычный случай: данные не пересекают границу буфера
		dataPtr := dataOffset + readIdx
		readData = PtrToByte(dataPtr, toRead)
		readIdx += toRead
	} else {
		// Wrap-around: данные пересекают границу буфера
		firstPart := dataSize - readIdx
		secondPart := toRead - firstPart

		// Читаем первую часть
		dataPtr1 := dataOffset + readIdx
		firstData := PtrToByte(dataPtr1, firstPart)

		// Читаем вторую часть
		dataPtr2 := dataOffset
		secondData := PtrToByte(dataPtr2, secondPart)

		// Объединяем части
		readData = make([]byte, toRead)
		copy(readData, firstData)
		copy(readData[firstPart:], secondData)
		readIdx = secondPart
	}

	// Копируем данные в выходной буфер
	copy(data, readData)

	// обновляем ReadIndex
	if err = UpdateRingBufferReadIndex(bufferPtr, readIdx); err != nil {
		return 0, err
	}

	return int(toRead), nil
}

// WriteToRingBuffer записывает данные в кольцевой буфер в WASM памяти.
// dataSize - кэшированный размер области данных (константа для буфера).
func WriteToRingBuffer(bufferPtr uint32, dataSize uint32, data []byte) (written int, err error) {

	if len(data) == 0 {
		return 0, nil
	}

	// Читаем только индексы и флаг закрытия (12 байт вместо 20)
	var readIdx, writeIdx, closed uint32
	if readIdx, writeIdx, closed, err = ReadIndicesAndClosed(bufferPtr); err != nil {
		return 0, err
	}

	if closed != 0 {
		return 0, io.EOF
	}

	// Вычисляем доступное место, используя кэшированный dataSize
	available := AvailableWrite(readIdx, writeIdx, dataSize)
	if available == 0 {
		return 0, nil // Буфер полон
	}

	// Ограничиваем размер данных доступным местом
	// Проверяем переполнение при конвертации int -> uint32
	dataLen := len(data)
	if dataLen < 0 || dataLen > int(^uint32(0)) {
		return 0, errors.New(i18n.Msg("data length out of range"))
	}
	toWrite := uint32(dataLen)
	if toWrite > available {
		toWrite = available
	}

	dataOffset := bufferPtr + RingBufferOffset

	// Записываем данные с учетом wrap-around
	if writeIdx+toWrite <= dataSize {
		// Обычный случай: данные не пересекают границу буфера
		dataPtr := dataOffset + writeIdx
		ByteToPtr(data[:toWrite], dataPtr)
		writeIdx += toWrite
	} else {
		// Wrap-around: данные пересекают границу буфера
		firstPart := dataSize - writeIdx
		secondPart := toWrite - firstPart

		// Записываем первую часть
		dataPtr1 := dataOffset + writeIdx
		ByteToPtr(data[:firstPart], dataPtr1)

		// Записываем вторую часть
		dataPtr2 := dataOffset
		ByteToPtr(data[firstPart:firstPart+secondPart], dataPtr2)
		writeIdx = secondPart
	}

	// обновляем WriteIndex
	if err = UpdateRingBufferWriteIndex(bufferPtr, writeIdx); err != nil {
		return 0, err
	}

	return int(toWrite), nil
}

// IsWriteBufferEmpty проверяет, пуст ли буфер записи (все данные прочитаны).
// Возвращает true, если ReadIndex == WriteIndex (буфер пуст).
// Оптимизировано: читает только индексы (8 байт) вместо всего заголовка (20 байт).
func IsWriteBufferEmpty(bufferPtr uint32) (isEmpty bool, err error) {

	// Читаем только индексы (8 байт) вместо всего заголовка
	var readIdx, writeIdx, closed uint32
	if readIdx, writeIdx, closed, err = ReadIndicesAndClosed(bufferPtr); err != nil {
		return false, err
	}

	// Буфер пуст, если ReadIndex == WriteIndex
	// closed не используется, но уже прочитан в ReadIndicesAndClosed
	_ = closed
	isEmpty = readIdx == writeIdx
	return isEmpty, nil
}
