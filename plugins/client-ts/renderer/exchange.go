// Copyright (c) 2026 Khramtsov Aleksei (seniorGolang@gmail.com).
// conditions defined in file 'LICENSE', which is part of this project source code.
package renderer

import (
	"tgp/plugins/client-ts/tsg"

	"fmt"
	"path"
	"strings"

	"tgp/internal/common"
	"tgp/internal/model"
)

func (r *ClientRenderer) RenderExchangeTypes(contract *model.Contract) (err error) {
	outDir := r.outDir
	r.contract = contract
	r.knownTypes = make(map[string]int)
	r.typeDefTs = make(map[string]typeDefTs)

	for _, method := range contract.Methods {
		args := r.argsWithoutContext(method)
		for _, arg := range args {
			_ = r.walkVariable(arg.Name, contract.PkgPath, arg, method.Annotations, true)
		}
		results := r.resultsWithoutError(method)
		for _, ret := range results {
			_ = r.walkVariable(ret.Name, contract.PkgPath, ret, method.Annotations, false)
		}
	}

	file := tsg.NewFile()
	file.Comment("// GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.\n")
	file.Line()

	typeByPackage := make(map[string]map[string]typeDefTs) // pkg -> name -> def
	var standaloneTypes []typeDefTs
	seenStandalone := make(map[string]bool)

	for key, def := range common.SortedPairs(r.typeDefTs) {
		if def.importPkg != "" {
			if typeByPackage[def.importPkg] == nil {
				typeByPackage[def.importPkg] = make(map[string]typeDefTs)
			}
			typeName := def.importName
			if typeName == "" {
				typeName = def.name
			}
			existing, exists := typeByPackage[def.importPkg][typeName]
			switch {
			case !exists:
				typeByPackage[def.importPkg][typeName] = def
			case len(def.properties) > len(existing.properties):
				typeByPackage[def.importPkg][typeName] = def
			case len(def.properties) == 0 && len(existing.properties) > 0:
			default:
				typeByPackage[def.importPkg][typeName] = def
			}
		} else if !seenStandalone[key] {
			standaloneTypes = append(standaloneTypes, def)
			seenStandalone[key] = true
		}
	}

	for _, def := range standaloneTypes {
		file.Add(r.renderTypeDef(def))
		file.Line()
	}

	exportedTypes := make(map[string]bool)
	for pkgName, typesMap := range common.SortedPairs(typeByPackage) {
		typesList := make([]typeDefTs, 0, len(typesMap))
		for _, def := range common.SortedPairs(typesMap) {
			typesList = append(typesList, def)
		}
		file.Add(r.renderNamespace(pkgName, typesList))
		file.Line()
		for _, def := range typesList {
			interfaceName := def.importName
			if interfaceName == "" {
				interfaceName = def.name
			}
			if interfaceName != "" {
				if exportedTypes[interfaceName] {
					continue
				}
				exportedTypes[interfaceName] = true
				switch def.kind {
				case "struct":
					exportStmt := tsg.NewStatement()
					exportStmt.Export().TypeAlias(interfaceName)
					exportStmt.Id(pkgName).Dot(interfaceName).Semicolon()
					file.Add(exportStmt)
					file.Line()
				case "scalar":
					exportStmt := tsg.NewStatement()
					exportStmt.Export().TypeAlias(interfaceName)
					exportStmt.Id(pkgName).Dot(interfaceName).Semicolon()
					file.Add(exportStmt)
					file.Line()
				}
			}
		}
	}

	for _, method := range contract.Methods {
		requestType := r.renderExchangeRequestType(contract, method)
		file.Add(requestType)
		file.Line()

		responseType := r.renderExchangeResponseType(contract, method)
		file.Add(responseType)
		file.Line()
	}

	file.GenerateImports()

	outFilename := path.Join(outDir, fmt.Sprintf("%s-exchange.ts", r.tsFileName(contract)))
	return file.Save(outFilename)
}

func (r *ClientRenderer) renderExchangeRequestType(contract *model.Contract, method *model.Method) *tsg.Statement {
	requestName := r.requestTypeName(contract, method)

	stmt := tsg.NewStatement()

	filteredDocs := r.filterDocsComments(method.Docs)
	if len(filteredDocs) > 0 {
		stmt.Comment(fmt.Sprintf("Request type for %s.%s", contract.Name, method.Name))
		stmt.Comment(strings.Join(filteredDocs, "\n"))
	} else {
		stmt.Comment(fmt.Sprintf("Request type for %s.%s", contract.Name, method.Name))
	}

	args := r.argsWithoutContext(method)
	if len(args) == 0 {
		stmt.Comment("Formal exchange type, please do not delete.")
		stmt.Export().TypeAlias(requestName)
		stmt.Id("Record").Generic("string", "never")
		stmt.Semicolon()
	} else {
		stmt.Export().Interface(requestName, func(grp *tsg.Group) {
			for _, arg := range args {
				typeStr := r.walkVariable(arg.Name, contract.PkgPath, arg, method.Annotations, true).typeLink()

				field := tsg.NewStatement()
				field.Id(tsSafeName(arg.Name))
				if model.IsAnnotationSet(r.project, contract, method, nil, "nullable") {
					field.Optional()
				}
				field.Colon()
				field.Add(tsg.TypeFromString(typeStr))
				field.Semicolon()
				grp.Add(field)
			}
		})
	}
	return stmt
}

func (r *ClientRenderer) renderExchangeResponseType(contract *model.Contract, method *model.Method) *tsg.Statement {
	responseName := r.responseTypeName(contract, method)

	stmt := tsg.NewStatement()

	filteredDocs := r.filterDocsComments(method.Docs)
	if len(filteredDocs) > 0 {
		stmt.Comment(fmt.Sprintf("Response type for %s.%s", contract.Name, method.Name))
		stmt.Comment(strings.Join(filteredDocs, "\n"))
	} else {
		stmt.Comment(fmt.Sprintf("Response type for %s.%s", contract.Name, method.Name))
	}

	results := r.resultsWithoutError(method)
	switch len(results) {
	case 0:
		stmt.Comment("Formal exchange type, please do not delete.")
		stmt.Export().TypeAlias(responseName)
		stmt.Void()
		stmt.Semicolon()
	case 1:
		if model.IsAnnotationSet(r.project, contract, method, nil, model.TagHttpEnableInlineSingle) {
			typeStr := r.walkVariable(results[0].Name, contract.PkgPath, results[0], method.Annotations, false).typeLink()
			stmt.Export().TypeAlias(responseName)
			stmt.Add(tsg.TypeFromString(typeStr))
			stmt.Semicolon()
		} else {
			ret := results[0]
			typeStr := r.walkVariable(ret.Name, contract.PkgPath, ret, method.Annotations, false).typeLink()
			stmt.Export().Interface(responseName, func(grp *tsg.Group) {
				field := tsg.NewStatement()
				field.Id(tsSafeName(ret.Name))
				if model.IsAnnotationSet(r.project, contract, method, nil, "nullable") {
					field.Optional()
				}
				field.Colon()
				field.Add(tsg.TypeFromString(typeStr))
				field.Semicolon()
				grp.Add(field)
			})
		}
	default:
		if r.responseHasAnyInline(method, results) {
			seen := make(map[string]bool)
			stmt.Export().Interface(responseName, func(grp *tsg.Group) {
				for _, ret := range results {
					if r.resultHasJsonInline(method, ret) {
						typ, ok := r.project.Types[ret.TypeID]
						if ok && typ.Kind == model.TypeKindStruct && typ.StructFields != nil {
							for _, f := range typ.StructFields {
								jsonName, inline := r.jsonName(f)
								if jsonName == "" || jsonName == "-" || inline {
									continue
								}
								if seen[jsonName] {
									continue
								}
								seen[jsonName] = true
								fieldVar := &model.Variable{TypeRef: f.TypeRef, Name: f.Name}
								typeStr := r.walkVariable(f.Name, typ.ImportPkgPath, fieldVar, nil, false).typeLink()
								field := tsg.NewStatement()
								field.Id(tsSafeName(jsonName))
								field.Colon()
								field.Add(tsg.TypeFromString(typeStr))
								field.Semicolon()
								grp.Add(field)
							}
						}
					} else {
						name := tsSafeName(ret.Name)
						if seen[name] {
							continue
						}
						seen[name] = true
						typeStr := r.walkVariable(ret.Name, contract.PkgPath, ret, method.Annotations, false).typeLink()
						field := tsg.NewStatement()
						field.Id(name)
						if model.IsAnnotationSet(r.project, contract, method, nil, "nullable") {
							field.Optional()
						}
						field.Colon()
						field.Add(tsg.TypeFromString(typeStr))
						field.Semicolon()
						grp.Add(field)
					}
				}
			})
		} else {
			stmt.Export().Interface(responseName, func(grp *tsg.Group) {
				for _, ret := range results {
					typeStr := r.walkVariable(ret.Name, contract.PkgPath, ret, method.Annotations, false).typeLink()

					field := tsg.NewStatement()
					field.Id(tsSafeName(ret.Name))
					if model.IsAnnotationSet(r.project, contract, method, nil, "nullable") {
						field.Optional()
					}
					field.Colon()
					field.Add(tsg.TypeFromString(typeStr))
					field.Semicolon()
					grp.Add(field)
				}
			})
		}
	}
	return stmt
}

func (r *ClientRenderer) filterDocsComments(docs []string) []string {
	if len(docs) == 0 {
		return docs
	}
	var filtered []string
	for _, doc := range docs {
		if !strings.Contains(doc, "@tg") {
			filtered = append(filtered, doc)
		}
	}
	return filtered
}

func (r *ClientRenderer) argsWithoutContext(method *model.Method) []*model.Variable {
	args := make([]*model.Variable, 0, len(method.Args))
	for _, arg := range method.Args {
		if arg.TypeID == "context:Context" || arg.TypeID == "context.Context" {
			continue
		}
		args = append(args, arg)
	}
	return args
}

func (r *ClientRenderer) resultsWithoutError(method *model.Method) []*model.Variable {
	results := make([]*model.Variable, 0, len(method.Results))
	for _, result := range method.Results {
		if result.TypeID == "error" || result.TypeID == "builtin:error" {
			continue
		}
		results = append(results, result)
	}
	return results
}

func (r *ClientRenderer) renderTypeDef(def typeDefTs) *tsg.Statement {
	stmt := tsg.NewStatement()

	switch def.kind {
	case "constant":
		if len(def.properties) > 1 {
			if def.typeName == "iota" {
				var cnt int
				for key := range common.SortedPairs(def.properties) {
					stmt.Add(tsg.NewStatement().Const(key).Op("=").Lit(cnt).Semicolon().Export())
					cnt++
				}
			} else {
				stmt.Add(
					tsg.NewStatement().
						Id("enum").
						Id(def.typeName).
						Values(func(grp *tsg.Group) {
							for key := range common.SortedPairs(def.properties) {
								grp.Add(tsg.NewStatement().Id(key).Semicolon())
							}
						}).
						Export(),
				)
			}
		} else {
			stmt.Add(tsg.NewStatement().Const(def.name).Op("=").Lit(def.value).Semicolon().Export())
		}
	case "struct":
		stmt.Comment(fmt.Sprintf("Тип %s", def.name))
		stmt.Interface(def.name, func(grp *tsg.Group) {
			for name, property := range common.SortedPairs(def.properties) {
				typeStr := castTypeTs(property.def())
				field := tsg.NewStatement().
					Id(name)
				if property.nullable {
					field.Optional()
				}
				grp.Add(field.Colon().Add(tsg.TypeFromString(typeStr)).Semicolon())
			}
		})
		stmt.Export()
	}

	return stmt
}

func (r *ClientRenderer) renderNamespace(pkgName string, types []typeDefTs) *tsg.Statement {
	stmt := tsg.NewStatement()
	stmt.Export().Namespace(pkgName, func(grp *tsg.Group) {
		for _, def := range types {
			interfaceName := def.importName
			if interfaceName == "" {
				interfaceName = def.name
			}
			if interfaceName == "" {
				for key, d := range common.SortedPairs(r.typeDefTs) {
					if d.importPkg == pkgName && d.importName != "" {
						interfaceName = d.importName
						break
					}
					if strings.HasPrefix(key, pkgName+":") {
						parts := strings.SplitN(key, ":", 2)
						if len(parts) == 2 {
							interfaceName = parts[1]
							break
						}
					}
				}
			}
			if interfaceName == "" {
				continue
			}
			switch def.kind {
			case "struct":
				ifStmt := tsg.NewStatement()
				ifStmt.Interface(interfaceName, func(ig *tsg.Group) {
					for name, property := range common.SortedPairs(def.properties) {
						typeStr := castTypeTs(property.def())
						field := tsg.NewStatement().
							Id(name)
						if property.nullable {
							field.Optional()
						}
						ig.Add(field.Colon().Add(tsg.TypeFromString(typeStr)).Semicolon())
					}
				})
				ifStmt.Export()
				grp.Add(ifStmt)
			case "map":
				keyType := def.properties["key"]
				valueType := def.properties["value"]
				typeAliasStmt := tsg.NewStatement()
				typeAliasStmt.TypeAlias(interfaceName)
				recordType := fmt.Sprintf("Record<%s, %s>", castTypeTs(keyType.typeLink()), castTypeTs(valueType.typeLink()))
				typeAliasStmt.Add(tsg.TypeFromString(recordType))
				typeAliasStmt.Semicolon()
				typeAliasStmt.Export()
				grp.Add(typeAliasStmt)
			case "scalar":
				typeAliasStmt := tsg.NewStatement()
				typeAliasStmt.TypeAlias(interfaceName)
				typeAliasStmt.Add(tsg.TypeFromString(def.typeName))
				typeAliasStmt.Semicolon()
				typeAliasStmt.Export()
				grp.Add(typeAliasStmt)
			}
		}
	})
	return stmt
}
