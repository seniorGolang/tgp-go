# GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.
name: Deploy Plugins

on:
  push:
    tags:
      - 'v*' # Поддержка тегов формата v{version} для деплоя всех плагинов

permissions:
  contents: write # Необходимо для создания релизов

jobs:
  # Для тега v{version} - деплоим все плагины
  detect_plugins:
    runs-on: ubuntu-latest
    container: alpine:latest
    if: startsWith(github.ref, 'refs/tags/v')
    outputs:
      plugins: ${{ steps.set_plugins.outputs.plugins }}
      version: ${{ steps.version.outputs.version }}
    steps:
      - uses: actions/checkout@v4
      - name: Install dependencies
        run: apk add --no-cache findutils jq
      - name: Extract version from tag
        id: version
        run: |
          TAG=${GITHUB_REF#refs/tags/}
          case "$TAG" in
            v*)
              PLUGIN_VERSION=${TAG#v}
              ;;
            *)
              echo "Неверный формат тега: $TAG (ожидается v{version})"
              exit 1
              ;;
          esac
          echo "version=$PLUGIN_VERSION" >> $GITHUB_OUTPUT
      - name: Detect plugins
        id: set_plugins
        run: |
          PLUGINS=$(find plugins -mindepth 1 -maxdepth 1 -type d -exec basename {} \; | sort)
          JSON_PLUGINS=$(echo "$PLUGINS" | jq -R -s -c 'split("\n") | map(select(length > 0))')
          echo "plugins=$JSON_PLUGINS" >> $GITHUB_OUTPUT

  build_all:
    needs: detect_plugins
    runs-on: ubuntu-latest
    container: golang:1.25-alpine
    if: startsWith(github.ref, 'refs/tags/v')
    strategy:
      matrix:
        plugin: ${{ fromJSON(needs.detect_plugins.outputs.plugins) }}
    steps:
      - uses: actions/checkout@v4

      - name: Install dependencies
        run: apk add --no-cache jq

      - name: Build plugin
        env:
          PLUGIN_DIR: ${{ matrix.plugin }}
          PLUGIN_VERSION: ${{ needs.detect_plugins.outputs.version }}
        run: |
          PLUGIN_DIR_PATH="plugins/$PLUGIN_DIR"
          mkdir -p dist

          # Генерируем манифест из кода
          cd "$PLUGIN_DIR_PATH"
          TEMP_MANIFEST="../../dist/temp_${PLUGIN_DIR}.json"
          if ! go run -tags pluginInfo . "$TEMP_MANIFEST" 2>&1; then
            echo "ОШИБКА: не удалось сгенерировать манифест для $PLUGIN_DIR"
            exit 1
          fi

          if [ ! -f "$TEMP_MANIFEST" ]; then
            echo "ОШИБКА: файл манифеста не создан для $PLUGIN_DIR"
            exit 1
          fi

          # Извлекаем имя плагина из сгенерированного манифеста
          PLUGIN_NAME=$(jq -r '.name' "$TEMP_MANIFEST")
          if [ -z "$PLUGIN_NAME" ] || [ "$PLUGIN_NAME" = "null" ]; then
            echo "ОШИБКА: Имя плагина не найдено в сгенерированном манифесте для $PLUGIN_DIR"
            exit 1
          fi

          # Обновляем версию в манифесте
          jq --arg version "$PLUGIN_VERSION" '.version = $version' "$TEMP_MANIFEST" > "../../dist/$PLUGIN_NAME.json"
          # Также сохраняем с именем директории для удобства поиска в следующем шаге (если имена отличаются)
          if [ "$PLUGIN_NAME" != "$PLUGIN_DIR" ]; then
            cp "../../dist/$PLUGIN_NAME.json" "../../dist/$PLUGIN_DIR.json"
          fi
          rm -f "$TEMP_MANIFEST"

          # Собираем плагин
          echo "Building plugin: $PLUGIN_NAME (directory: $PLUGIN_DIR)"
          cd ../..
          GOOS=wasip1 GOARCH=wasm go build -o "$PLUGIN_DIR_PATH/$PLUGIN_NAME.tgp" -buildmode=c-shared "./$PLUGIN_DIR_PATH"

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.plugin }}-artifacts
          path: |
            plugins/${{ matrix.plugin }}/*.tgp
            dist/${{ matrix.plugin }}.json

  deploy_all:
    needs: [detect_plugins, build_all]
    runs-on: ubuntu-latest
    container: alpine:latest
    if: startsWith(github.ref, 'refs/tags/v')
    steps:
      - uses: actions/checkout@v4

      - name: Install dependencies
        run: apk add --no-cache jq

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/

      - name: Prepare release files
        id: prepare
        env:
          PLUGINS_JSON: ${{ needs.detect_plugins.outputs.plugins }}
          VERSION: ${{ needs.detect_plugins.outputs.version }}
          REPO_URL: https://github.com/${{ github.repository }}
        run: |
          mkdir -p "release"

          # Генерируем YAML манифест
          echo "version: '$VERSION'" > release/manifest.yml
          echo "" >> release/manifest.yml
          echo "packages:" >> release/manifest.yml

          RELEASE_TAG="v$VERSION"
          FIRST_PACKAGE=true

          # Обрабатываем каждый плагин в одном цикле
          for PLUGIN_DIR in $(echo "$PLUGINS_JSON" | jq -r '.[]'); do
            ARTIFACT_DIR="artifacts/$PLUGIN_DIR-artifacts"
            
            # JSON файл всегда находится по пути dist/$PLUGIN_DIR.json в артефакте
            PLUGIN_JSON_ARTIFACT="$ARTIFACT_DIR/dist/$PLUGIN_DIR.json"
            if [ ! -f "$PLUGIN_JSON_ARTIFACT" ]; then
              echo "ОШИБКА: JSON манифест не найден в артефактах для плагина $PLUGIN_DIR по пути $PLUGIN_JSON_ARTIFACT" >&2
              exit 1
            fi
            
            # Извлекаем информацию о плагине из JSON
            PLUGIN_NAME=$(jq -r '.name' "$PLUGIN_JSON_ARTIFACT")
            if [ -z "$PLUGIN_NAME" ] || [ "$PLUGIN_NAME" = "null" ]; then
              echo "ОШИБКА: Имя плагина не найдено в манифесте для $PLUGIN_DIR" >&2
              exit 1
            fi
            
            PLUGIN_DESCR=$(jq -r '.description // ""' "$PLUGIN_JSON_ARTIFACT")
            PLUGIN_DEPS=$(jq -r '.dependencies // []' "$PLUGIN_JSON_ARTIFACT")
            
            # .tgp файл всегда находится в plugins/$PLUGIN_DIR/$PLUGIN_NAME.tgp внутри артефакта
            TGP_FILE="$ARTIFACT_DIR/plugins/$PLUGIN_DIR/$PLUGIN_NAME.tgp"
            if [ ! -f "$TGP_FILE" ]; then
              echo "ОШИБКА: Файл .tgp не найден для плагина $PLUGIN_NAME по пути $TGP_FILE" >&2
              exit 1
            fi
            
            DST="release/$PLUGIN_NAME.tgp"
            cp "$TGP_FILE" "$DST"
            gzip -9 -c "$DST" > "$DST.tmp" && mv "$DST.tmp" "$DST"
            echo "$DST" >> release_files.txt
            TGP_CHECKSUM=$(sha256sum "$DST" | awk '{print $1}')
            
            # Формируем URL и destination пути
            TGP_URL="$REPO_URL/releases/download/$RELEASE_TAG/$PLUGIN_NAME.tgp"
            TGP_DEST="plugins/$PLUGIN_DIR/$VERSION/$PLUGIN_NAME.tgp"
            
            # Добавляем пакет в манифест
            if [ "$FIRST_PACKAGE" = "true" ]; then
              FIRST_PACKAGE=false
            else
              echo "" >> release/manifest.yml
            fi
            
            echo "  - name: '$PLUGIN_NAME'" >> release/manifest.yml
            if [ -n "$PLUGIN_DESCR" ] && [ "$PLUGIN_DESCR" != "null" ]; then
              echo "    descr: '$PLUGIN_DESCR'" >> release/manifest.yml
            fi
            if [ "$PLUGIN_DEPS" != "[]" ] && [ "$PLUGIN_DEPS" != "null" ]; then
              echo "    dependencies:" >> release/manifest.yml
              echo "$PLUGIN_DEPS" | jq -r '.[]' | while IFS= read -r dep; do
                if [ -n "$dep" ]; then
                  echo "      - '$dep'" >> release/manifest.yml
                fi
              done
            fi
            echo "    downloads:" >> release/manifest.yml
            echo "      - url: '$TGP_URL'" >> release/manifest.yml
            echo "    files:" >> release/manifest.yml
            echo "      - file: '$PLUGIN_NAME.tgp'" >> release/manifest.yml
            echo "        destination: '$TGP_DEST'" >> release/manifest.yml
            echo "        checksum: 'sha256:$TGP_CHECKSUM'" >> release/manifest.yml
          done

          echo "release/manifest.yml" >> release_files.txt

          echo "files<<EOF" >> $GITHUB_OUTPUT
          cat release_files.txt >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.ref_name }}
          files: ${{ steps.prepare.outputs.files }}
          token: ${{ secrets.GITHUB_TOKEN }}
