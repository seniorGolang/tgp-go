//go:build wasip1

// GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.
package exec

import (
	"context"
	"fmt"
	"io"
	"runtime"

	"tgp/core/i18n"
	"tgp/core/wasm"
)

// Cmd представляет команду, готовую к выполнению.
// API аналогичен os/exec.Cmd, но скрывает WASM сложность.
type Cmd struct {
	Path    string
	Args    []string
	WorkDir string

	// Внутренние поля для WASM
	cmdResp *wasm.CommandResponse
	started bool
	ctx     context.Context
}

// Command создает новую команду для выполнения.
// name - имя команды (например, "echo")
// arg - аргументы команды
func Command(name string, arg ...string) (cmd *Cmd) {

	return &Cmd{
		Path:    name,
		Args:    arg,
		WorkDir: ".",
		ctx:     context.Background(),
	}
}

// CommandContext создает новую команду с контекстом для выполнения.
// ctx - контекст для отмены выполнения
// name - имя команды (например, "echo")
// arg - аргументы команды
func CommandContext(ctx context.Context, name string, arg ...string) (cmd *Cmd) {

	return &Cmd{
		Path:    name,
		Args:    arg,
		WorkDir: ".",
		ctx:     ctx,
	}
}

// Dir устанавливает рабочую директорию для команды.
func (c *Cmd) Dir(dir string) (cmd *Cmd) {

	c.WorkDir = dir
	return c
}

// Start запускает команду, но не ждет её завершения.
func (c *Cmd) Start() (err error) {

	if c.started {
		return fmt.Errorf(i18n.Msg("command already started"))
	}

	// Выполняем команду через WASM (внутренняя сложность скрыта)
	cmdResp, cmdErr := wasm.ExecuteCommandInDir(c.Path, c.Args, c.WorkDir)
	if cmdErr != nil {
		return fmt.Errorf(i18n.Msg("failed to execute command")+": %w", cmdErr)
	}

	c.cmdResp = cmdResp
	c.started = true

	return nil
}

// Wait ждет завершения команды и возвращает ошибку, если команда завершилась с ненулевым кодом выхода.
func (c *Cmd) Wait() (err error) {

	if !c.started {
		return fmt.Errorf(i18n.Msg("command not started"))
	}

	if c.cmdResp == nil {
		return fmt.Errorf(i18n.Msg("command response is nil"))
	}

	if c.cmdResp.Error != "" {
		return fmt.Errorf(i18n.Msg("command failed: %s"), c.cmdResp.Error)
	}

	// Ждём финальный exitCode от хоста. Команда выполняется асинхронно.
	// exitCode = -2 означает "команда еще не завершена"; опрашиваем до получения реального кода.
	if c.cmdResp.StdoutStreamID > 0 {
		stdoutStreamID := uint32(c.cmdResp.StdoutStreamID) //nolint:gosec // streamID всегда > 0
		for {
			if updatedResp, err := wasm.GetCommandResponse(stdoutStreamID); err == nil {
				c.cmdResp.ExitCode = updatedResp.ExitCode
				if updatedResp.ExitCode != -2 {
					break
				}
			}
			runtime.Gosched()
		}
	}

	if c.cmdResp.ExitCode != 0 {
		return fmt.Errorf(i18n.Msg("command exited with code %d"), c.cmdResp.ExitCode)
	}

	return nil
}

// Run запускает команду и ждет её завершения.
func (c *Cmd) Run() (err error) {

	if err := c.Start(); err != nil {
		return err
	}

	return c.Wait()
}

// StdoutPipe возвращает pipe для чтения stdout команды.
// Должен быть вызван до Start().
// После вызова Start() команда уже выполнена, поэтому pipe доступен сразу.
func (c *Cmd) StdoutPipe() (reader io.ReadCloser, err error) {

	// НЕ запускаем команду здесь - это должно быть сделано явно через Start()
	// StdoutPipe только возвращает reader, команда должна быть запущена отдельно

	if c.cmdResp == nil {
		return nil, fmt.Errorf(i18n.Msg("command not started: call Start() first"))
	}

	if c.cmdResp.StdoutStreamID == 0 {
		return nil, fmt.Errorf(i18n.Msg("stdout stream not available"))
	}

	// Создаем reader для чтения из потока
	// streamID всегда положительный, безопасное преобразование int32 -> uint32
	stdoutStreamID := uint32(c.cmdResp.StdoutStreamID) //nolint:gosec // streamID всегда > 0
	return wasm.NewStreamReader(stdoutStreamID), nil
}

// StderrPipe возвращает pipe для чтения stderr команды.
// Должен быть вызван до Start().
// После вызова Start() команда уже выполнена, поэтому pipe доступен сразу.
func (c *Cmd) StderrPipe() (reader io.ReadCloser, err error) {

	// НЕ запускаем команду здесь - это должно быть сделано явно через Start()
	// StderrPipe только возвращает reader, команда должна быть запущена отдельно

	if c.cmdResp == nil {
		return nil, fmt.Errorf(i18n.Msg("command not started: call Start() first"))
	}

	if c.cmdResp.StderrStreamID == 0 {
		return nil, fmt.Errorf(i18n.Msg("stderr stream not available"))
	}

	// Создаем reader для чтения из потока
	// streamID всегда положительный, безопасное преобразование int32 -> uint32
	stderrStreamID := uint32(c.cmdResp.StderrStreamID) //nolint:gosec // streamID всегда > 0
	return wasm.NewStreamReader(stderrStreamID), nil
}

// ExitCode возвращает код выхода команды.
// Должен быть вызван после Wait().
func (c *Cmd) ExitCode() (exitCode int) {

	if !c.started {
		return -1
	}

	if c.cmdResp == nil {
		return -1
	}

	// Если stdoutStreamID доступен, получаем обновленный CommandResponse из хоста
	if c.cmdResp.StdoutStreamID > 0 {
		// streamID всегда положительный, безопасное преобразование int32 -> uint32
		stdoutStreamID := uint32(c.cmdResp.StdoutStreamID) //nolint:gosec // streamID всегда > 0
		if updatedResp, err := wasm.GetCommandResponse(stdoutStreamID); err == nil {
			return updatedResp.ExitCode
		}
		// Если не удалось получить из хоста, возвращаем сохраненный в cmdResp
	}

	// Возвращаем exitCode из cmdResp (может быть 0 по умолчанию, если команда еще не завершилась)
	return c.cmdResp.ExitCode
}
