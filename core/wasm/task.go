//go:build wasip1

// GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.

package wasm

import (
	"encoding/binary"
	"fmt"
	"sync"
	"time"

	"github.com/goccy/go-json"

	"tgp/core/data"
	"tgp/core/i18n"
)

// TaskHandler представляет функцию-обработчик задачи.
// next: true = продолжаем выполнение через интервал, false = завершаем задачу
type TaskHandler func() (next bool)

var (
	// taskHandlerRegistry хранит зарегистрированные обработчики задач.
	taskHandlerRegistry          = make(map[uint32]TaskHandler)
	nextTaskHandlerID     uint32 = 1
	taskHandlerRegistryMu sync.Mutex
)

// registerTaskHandler регистрирует обработчик задачи и возвращает его ID.
func registerTaskHandler(handler TaskHandler) (handlerID uint32) {

	taskHandlerRegistryMu.Lock()
	defer taskHandlerRegistryMu.Unlock()

	handlerID = nextTaskHandlerID
	nextTaskHandlerID++
	taskHandlerRegistry[handlerID] = handler
	return handlerID
}

// getTaskHandler возвращает обработчик по ID.
// Используется в taskHandler, который вызывается из WASM хоста.
//
//nolint:unused // Используется через go:wasmexport task_handler
func getTaskHandler(handlerID uint32) (handler TaskHandler, ok bool) {

	taskHandlerRegistryMu.Lock()
	defer taskHandlerRegistryMu.Unlock()

	handler, ok = taskHandlerRegistry[handlerID]
	return handler, ok
}

// StartTask запускает фоновую задачу с указанным интервалом.
// interval - интервал между выполнениями
// handler - функция-обработчик, которая будет вызываться с интервалом
// Если handler возвращает false (next = false), задача автоматически останавливается
// Возвращает taskID для остановки задачи
func StartTask(interval time.Duration, handler TaskHandler) (taskID uint32, err error) {

	if handler == nil {
		return 0, fmt.Errorf(i18n.Msg("handler cannot be nil"))
	}

	// Регистрируем обработчик и получаем handlerID
	handlerID := registerTaskHandler(handler)

	// Проверяем переполнение при преобразовании int64 -> uint32
	intervalMsInt64 := interval.Milliseconds()
	if intervalMsInt64 < 0 || intervalMsInt64 > int64(^uint32(0)) {
		return 0, fmt.Errorf(i18n.Msg("interval too large for uint32: %d ms"), intervalMsInt64)
	}
	intervalMs := uint32(intervalMsInt64) //nolint:gosec // Проверка переполнения выполнена выше
	return startTask(intervalMs, handlerID)
}

// startTask запускает фоновую задачу с указанным интервалом в миллисекундах.
// intervalMs - интервал между выполнениями в миллисекундах
// handlerID - идентификатор функции-обработчика (task_handler будет вызван с этим ID)
// Возвращает taskID для остановки задачи
func startTask(intervalMs uint32, handlerID uint32) (taskID uint32, err error) {

	// Выделяем память для указателей результата
	resultPtrPtr := Malloc(4)
	resultSizePtr := Malloc(4)
	defer Free(resultPtrPtr)
	defer Free(resultSizePtr)

	// Вызываем функцию хоста напрямую
	if hostStartTask(intervalMs, handlerID, resultPtrPtr, resultSizePtr) != 0 {
		return 0, fmt.Errorf(i18n.Msg("failed to start task"))
	}

	// Читаем результат
	resultPtr := ReadUint32(resultPtrPtr)
	resultSize := ReadUint32(resultSizePtr)

	if resultSize == 0 {
		return 0, fmt.Errorf(i18n.Msg("empty response from host"))
	}

	// Читаем результат (в JSON формате)
	resultBytes := PtrToByte(resultPtr, resultSize)
	defer Free(resultPtr)

	// Декодируем JSON ответ
	var response taskResponse
	if err = json.Unmarshal(resultBytes, &response); err != nil {
		return 0, fmt.Errorf(i18n.Msg("failed to decode response")+": %w", err)
	}

	// Проверяем наличие ошибки
	if response.Error != "" {
		return 0, fmt.Errorf(i18n.Msg("task error: %s"), response.Error)
	}

	// Десериализуем Response в MapStorage
	var parsedTaskID uint32
	if len(response.Response) > 0 {
		var responseStorage data.MapStorage
		if err = json.Unmarshal(response.Response, &responseStorage); err == nil {
			if parsedTaskID, err = data.Get[uint32](&responseStorage, "taskID"); err != nil {
				return 0, fmt.Errorf(i18n.Msg("failed to get taskID from response")+": %w", err)
			}
		}
	}

	// Регистрируем активную задачу
	registerActiveTask(parsedTaskID)

	return parsedTaskID, nil
}

// StopTask останавливает задачу по taskID.
func StopTask(taskID uint32) (err error) {

	// Выделяем память для taskID
	taskIDPtr := Malloc(4)
	defer Free(taskIDPtr)
	WriteUint32(taskIDPtr, taskID)

	// Выделяем память для указателей результата
	resultPtrPtr := Malloc(4)
	resultSizePtr := Malloc(4)
	defer Free(resultPtrPtr)
	defer Free(resultSizePtr)

	// Вызываем функцию хоста напрямую
	if hostStopTask(taskIDPtr, resultPtrPtr, resultSizePtr) != 0 {
		return fmt.Errorf(i18n.Msg("failed to stop task"))
	}

	// Читаем результат
	resultPtr := ReadUint32(resultPtrPtr)
	resultSize := ReadUint32(resultSizePtr)

	if resultSize == 0 {
		return fmt.Errorf(i18n.Msg("empty response from host"))
	}

	// Читаем результат (в JSON формате)
	resultBytes := PtrToByte(resultPtr, resultSize)
	defer Free(resultPtr)

	// Декодируем JSON ответ
	var response struct {
		Error    string          `json:"error,omitempty"`
		Response json.RawMessage `json:"response,omitempty"`
	}
	if err = json.Unmarshal(resultBytes, &response); err != nil {
		return fmt.Errorf(i18n.Msg("failed to decode response")+": %w", err)
	}

	// Проверяем наличие ошибки
	if response.Error != "" {
		// Удаляем задачу из списка активных даже при ошибке
		unregisterActiveTask(taskID)
		return fmt.Errorf(i18n.Msg("task error: %s"), response.Error)
	}

	// Удаляем задачу из списка активных
	unregisterActiveTask(taskID)

	return nil
}

// activeTasks хранит активные задачи для StopAll.
var (
	activeTasks   = make(map[uint32]struct{})
	activeTasksMu sync.Mutex
)

// StopAll останавливает все активные задачи.
func StopAll() (err error) {

	// Выделяем память для указателей результата
	resultPtrPtr := Malloc(4)
	resultSizePtr := Malloc(4)
	defer Free(resultPtrPtr)
	defer Free(resultSizePtr)

	// Вызываем функцию хоста напрямую
	if hostStopAllTasks(resultPtrPtr, resultSizePtr) != 0 {
		return fmt.Errorf(i18n.Msg("failed to stop all tasks"))
	}

	// Читаем результат
	resultPtr := ReadUint32(resultPtrPtr)
	resultSize := ReadUint32(resultSizePtr)

	if resultSize == 0 {
		return fmt.Errorf(i18n.Msg("empty response from host"))
	}

	// Читаем результат (в JSON формате)
	resultBytes := PtrToByte(resultPtr, resultSize)
	defer Free(resultPtr)

	// Декодируем JSON ответ
	var response struct {
		Error    string          `json:"error,omitempty"`
		Response json.RawMessage `json:"response,omitempty"`
	}
	if err = json.Unmarshal(resultBytes, &response); err != nil {
		return fmt.Errorf(i18n.Msg("failed to decode response")+": %w", err)
	}

	// Проверяем наличие ошибки
	if response.Error != "" {
		return fmt.Errorf(i18n.Msg("task error: %s"), response.Error)
	}

	// Очищаем список активных задач
	activeTasksMu.Lock()
	activeTasks = make(map[uint32]struct{})
	activeTasksMu.Unlock()

	return nil
}

// registerActiveTask регистрирует активную задачу.
func registerActiveTask(taskID uint32) {

	activeTasksMu.Lock()
	activeTasks[taskID] = struct{}{}
	activeTasksMu.Unlock()
}

// unregisterActiveTask удаляет задачу из списка активных.
func unregisterActiveTask(taskID uint32) {

	activeTasksMu.Lock()
	delete(activeTasks, taskID)
	activeTasksMu.Unlock()
}

// taskHandler обрабатывает вызов задачи от хоста.
// Сигнатура: (handlerIDPtr uint32, handlerIDSize uint32) -> next uint64
// Экспортируется для вызова из хоста.
// next: нижние 32 бита содержат next (1 = true, 0 = false)
//
//go:wasmexport task_handler
//nolint:unused // Экспортируется через WASM
func taskHandler(handlerIDPtr uint32, handlerIDSize uint32) (next uint64) {

	// Читаем handlerID из памяти
	if handlerIDSize != 4 {
		return 0 // Неверный размер - завершаем задачу
	}

	handlerIDBytes := PtrToByte(handlerIDPtr, handlerIDSize)
	handlerID := binary.LittleEndian.Uint32(handlerIDBytes)

	// Получаем обработчик по ID
	handler, ok := getTaskHandler(handlerID)
	if !ok {
		return 0 // Обработчик не найден - завершаем задачу
	}

	// Вызываем обработчик
	shouldContinue := handler()
	if shouldContinue {
		return 1 // Продолжаем выполнение через интервал
	}

	return 0 // Завершаем задачу
}

// hostStartTask вызывает функцию хоста для запуска задачи.
//
//go:wasmimport env host_start_task
func hostStartTask(intervalMs uint32, handlerID uint32, resultPtrPtr uint32, resultSizePtr uint32) (resultCode uint32)

// hostStopTask вызывает функцию хоста для остановки задачи.
//
//go:wasmimport env host_stop_task
func hostStopTask(taskIDPtr uint32, resultPtrPtr uint32, resultSizePtr uint32) (resultCode uint32)

// hostStopAllTasks вызывает функцию хоста для остановки всех задач.
//
//go:wasmimport env host_stop_all_tasks
func hostStopAllTasks(resultPtrPtr uint32, resultSizePtr uint32) (resultCode uint32)
