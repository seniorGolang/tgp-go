// Copyright (c) 2026 Khramtsov Aleksei (seniorGolang@gmail.com).
// conditions defined in file 'LICENSE', which is part of this project source code.
package renderer

import (
	"fmt"
	"log/slog"
	"path"

	"tgp/plugins/client-ts/tsg"

	"tgp/core/i18n"
	"tgp/internal/common"
	"tgp/internal/content"
	"tgp/internal/model"
)

func (r *ClientRenderer) RenderHTTPClientClass(contract *model.Contract) (err error) {

	if contract == nil {
		slog.Error(i18n.Msg("RenderHTTPClientClass: contract is nil"))
		return fmt.Errorf("contract is nil")
	}
	if contract.PkgPath == "" {
		slog.Error(i18n.Msg("RenderHTTPClientClass: contract.PkgPath is empty"), slog.String("contract", contract.Name))
		return fmt.Errorf("contract.PkgPath is empty for contract %s", contract.Name)
	}

	outDir := r.outDir
	r.contract = contract
	r.knownTypes = make(map[string]int)
	r.typeDefTs = make(map[string]typeDefTs)

	file := tsg.NewFile()
	file.Comment("// GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.\n")

	file.ImportNamed("./client", "Client")

	file.Line()

	for _, method := range contract.Methods {
		if !r.isHTTP(method, contract) {
			continue
		}
		args := r.argsWithoutContext(method)
		for _, arg := range args {
			_ = r.walkVariable(arg.Name, contract.PkgPath, arg, method.Annotations, true)
		}
		results := r.resultsWithoutError(method)
		for _, ret := range results {
			_ = r.walkVariable(ret.Name, contract.PkgPath, ret, method.Annotations, false)
		}
	}

	exchangePath := fmt.Sprintf("./%s-exchange", r.tsFileName(contract))
	exchangeTypes := make([]string, 0, len(contract.Methods)*2)
	seenTypes := make(map[string]bool)
	for _, method := range contract.Methods {
		if !r.isHTTP(method, contract) {
			continue
		}
		args := r.argsWithoutContext(method)
		if len(args) > 0 {
			requestType := r.requestTypeName(contract, method)
			if !seenTypes[requestType] {
				exchangeTypes = append(exchangeTypes, requestType)
				seenTypes[requestType] = true
			}
		}
		results := r.resultsWithoutError(method)
		if len(results) > 0 {
			if r.methodResponseMultipart(contract, method) || r.methodResponseBodyStreamResult(method) != nil {
				continue
			}
			responseType := r.responseTypeName(contract, method)
			if !seenTypes[responseType] {
				exchangeTypes = append(exchangeTypes, responseType)
				seenTypes[responseType] = true
			}
		}
	}
	if len(exchangeTypes) > 0 {
		file.ImportType(exchangePath, exchangeTypes...)
	}
	kindsUsed := make(map[string]struct{})
	for _, method := range contract.Methods {
		if !r.isHTTP(method, contract) {
			continue
		}
		kindsUsed[content.Kind(model.GetAnnotationValue(r.project, contract, method, nil, model.TagRequestContentType, "application/json"))] = struct{}{}
		kindsUsed[content.Kind(model.GetAnnotationValue(r.project, contract, method, nil, model.TagResponseContentType, "application/json"))] = struct{}{}
	}
	for k := range kindsUsed {
		switch k {
		case content.KindXML:
			file.ImportNamed("fast-xml-parser", "XMLBuilder", "XMLParser")
		case content.KindMsgpack:
			file.ImportAll("@msgpack/msgpack", "Msgpack")
		case content.KindCBOR:
			file.ImportAll("cbor-x", "Cbor")
		case content.KindYAML:
			file.Import("yaml", "YAML")
		}
	}
	hasDtoTypes := false
	for _, def := range common.SortedPairs(r.typeDefTs) {
		if def.importPkg == "dto" {
			hasDtoTypes = true
			break
		}
	}
	if hasDtoTypes {
		file.ImportAll(exchangePath, "dto")
	}

	importedTypes := make(map[string]bool)
	for _, typeName := range exchangeTypes {
		importedTypes[typeName] = true
	}

	typeByPackage := make(map[string][]typeDefTs)
	var standaloneTypes []typeDefTs

	for _, def := range common.SortedPairs(r.typeDefTs) {
		typeName := def.importName
		if typeName == "" {
			typeName = def.name
		}
		if importedTypes[typeName] {
			continue
		}
		if def.importPkg == "dto" {
			continue
		}

		if def.importPkg != "" {
			typeByPackage[def.importPkg] = append(typeByPackage[def.importPkg], def)
		} else {
			standaloneTypes = append(standaloneTypes, def)
		}
	}

	for _, def := range standaloneTypes {
		file.Add(r.renderTypeDef(def))
		file.Line()
	}

	for pkgName, types := range common.SortedPairs(typeByPackage) {
		file.Add(r.renderNamespace(pkgName, types))
		file.Line()
	}

	allErrorsMap := make(map[string]errorInfo)
	for _, method := range contract.Methods {
		if !r.isHTTP(method, contract) {
			continue
		}
		methodErrors := r.collectMethodErrors(method, contract)
		for key, errInfo := range methodErrors {
			if _, exists := allErrorsMap[key]; !exists {
				allErrorsMap[key] = errInfo
			}
		}
	}

	for _, errInfo := range common.SortedPairs(allErrorsMap) {
		file.Add(r.renderErrorType(errInfo))
		file.Line()
	}

	for _, method := range contract.Methods {
		if !r.isHTTP(method, contract) {
			continue
		}
		methodErrors := r.collectMethodErrors(method, contract)
		if len(methodErrors) > 0 {
			unionType := r.renderErrorUnionType(method.Name, methodErrors)
			if unionType != nil {
				file.Add(unionType)
				file.Line()
			}
		}
	}

	if _, hasForm := kindsUsed[content.KindForm]; hasForm {
		file.Add(r.renderFormParseHelper())
		file.Line()
	}

	clientClass := r.renderHTTPClientClass(contract)
	file.Add(clientClass)
	file.Line()

	file.GenerateImports()

	outFilename := path.Join(outDir, fmt.Sprintf("%s-http.ts", r.tsFileName(contract)))
	return file.Save(outFilename)
}

func (r *ClientRenderer) renderHTTPClientClass(contract *model.Contract) *tsg.Statement {
	// Захват contract в замыкании: r.contract может меняться при обходе контрактов.
	currentContract := contract

	stmt := tsg.NewStatement()
	stmt.Comment(fmt.Sprintf("HTTP клиент для сервиса %s", contract.Name))
	stmt.Export().Class(contract.Name+"HTTPClient", func(grp *tsg.Group) {
		grp.Add(tsg.NewStatement().Private().Id("baseClient").Colon().Id("Client").Semicolon())
		grp.Line()

		constructor := tsg.NewStatement()
		constructor.Comment(fmt.Sprintf("Creates a new HTTP client for %s service", contract.Name))
		constructorStmt := tsg.NewStatement()
		constructorStmt.Id("constructor")
		constructorStmt.Params(func(cg *tsg.Group) {
			cg.Add(tsg.NewStatement().Id("_baseClient").Colon().Id("Client"))
		})
		constructorStmt.BlockFunc(func(cg *tsg.Group) {
			cg.Add(tsg.NewStatement().This().Dot("baseClient").Op("=").Id("_baseClient").Semicolon())
		})
		grp.Add(constructorStmt)
		grp.Line()

		if r.contract == nil {
			slog.Error(i18n.Msg("renderHTTPClientClass: r.contract is nil in closure"))
			return
		}
		for _, method := range currentContract.Methods {
			if !r.isHTTP(method, currentContract) {
				continue
			}
			r.renderHTTPMethod(grp, method, currentContract)
		}
	})
	stmt.Export()
	return stmt
}
