// Copyright (c) 2026 Khramtsov Aleksei (seniorGolang@gmail.com).
// conditions defined in file 'LICENSE', which is part of this project source code.
package cleanup

import (
	"bufio"
	"log/slog"
	"os"
	"path"
	"strings"

	"tgp/core/i18n"
)

// GeneratedFiles удаляет .go/.ts с маркером "GENERATED BY ... DO NOT EDIT" и пустые подкаталоги.
func GeneratedFiles(outDir string) (err error) {

	var files []os.DirEntry
	if files, err = os.ReadDir(outDir); err != nil {
		slog.Warn(i18n.Msg("failed to read directory during cleanup"), slog.String("directory", outDir), slog.String("error", err.Error()))
		return err
	}

	for _, file := range files {
		filePath := path.Join(outDir, file.Name())
		if file.IsDir() {
			if err = GeneratedFiles(filePath); err != nil {
				slog.Warn(i18n.Msg("failed to cleanup subdirectory"), slog.String("directory", filePath), slog.String("error", err.Error()))
			}
			if isEmpty, _ := isDirEmpty(filePath); isEmpty {
				if err = os.Remove(filePath); err != nil {
					slog.Warn(i18n.Msg("failed to remove empty directory during cleanup"), slog.String("directory", filePath), slog.String("error", err.Error()))
				}
			}
			continue
		}

		ext := strings.ToLower(path.Ext(file.Name()))
		if ext != ".go" && ext != ".ts" {
			continue
		}

		if genFile, err := os.Open(filePath); err == nil {
			reader := bufio.NewReader(genFile)
			found := false
			for i := 0; i < 10; i++ {
				line, err := reader.ReadString('\n')
				if err != nil {
					break
				}
				if strings.Contains(line, "GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.") {
					found = true
					break
				}
			}
			_ = genFile.Close()

			if found {
				if err = os.Remove(filePath); err != nil {
					slog.Warn(i18n.Msg("failed to remove generated file during cleanup"), slog.String("file", filePath), slog.String("error", err.Error()))
				}
			}
		}
	}

	return
}

func isDirEmpty(dirPath string) (empty bool, err error) {

	entries, err := os.ReadDir(dirPath)
	if err != nil {
		return false, err
	}
	return len(entries) == 0, nil
}
