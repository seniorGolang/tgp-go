//go:build wasip1

// GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.
package net

import (
	"encoding/binary"
	"fmt"
	"log/slog"
	"net"
	"sync"

	"tgp/core/i18n"
	"tgp/core/wasm"
)

// Listener представляет слушатель сетевых соединений.
type Listener struct {
	id      uint64
	address string
	mu      sync.Mutex
	closed  bool
	serving bool
}

// ID возвращает ID listener'а.
func (l *Listener) ID() (id uint64) {

	return l.id
}

// Listen создаёт слушатель на указанном адресе.
func Listen(network, address string) (listener *Listener, err error) {

	// Преобразуем строки в указатели
	networkPtr, networkLen := wasm.StringToPtr(network)
	defer wasm.Free(networkPtr)

	addressPtr, addressLen := wasm.StringToPtr(address)
	defer wasm.Free(addressPtr)

	// Выделяем память для listenerID (4 байта для uint32)
	listenerIDPtr := wasm.Malloc(4)
	if listenerIDPtr == 0 {
		return nil, fmt.Errorf(i18n.Msg("failed to allocate memory for listenerID"))
	}
	defer wasm.Free(listenerIDPtr)

	// Вызываем host функцию
	ret := listener_listen(networkPtr, networkLen, addressPtr, addressLen, listenerIDPtr)

	// Обрабатываем ошибку
	if err = wasm.HandleHostError(ret); err != nil {
		return nil, err
	}

	// Читаем listenerID из памяти (little-endian uint32)
	listenerIDBytes := wasm.PtrToByte(listenerIDPtr, 4)
	if len(listenerIDBytes) < 4 {
		return nil, fmt.Errorf(i18n.Msg("invalid listenerID data size: expected 4, got %d"), len(listenerIDBytes))
	}

	listenerID := binary.LittleEndian.Uint32(listenerIDBytes)

	return &Listener{
		id:      uint64(listenerID),
		address: address,
	}, nil
}

// Close закрывает слушатель.
// Реализует интерфейс net.Listener.
func (l *Listener) Close() (err error) {

	l.mu.Lock()
	if l.closed {
		l.mu.Unlock()
		return nil
	}
	l.closed = true
	l.mu.Unlock()

	// Вызываем host функцию
	ret := listener_close(l.id)

	// Обрабатываем ошибку
	if err = wasm.HandleHostError(ret); err != nil {
		return err
	}

	return nil
}

// Addr возвращает адрес слушателя.
// Реализует интерфейс net.Listener.
func (l *Listener) Addr() (a net.Addr) {

	// Выделяем память для адреса (256 байт должно быть достаточно)
	addrPtr := wasm.Malloc(256)
	if addrPtr == 0 {
		return &addr{address: l.address}
	}
	defer wasm.Free(addrPtr)

	// Выделяем память для размера (4 байта для uint32)
	// addrLenPtr используется как входной (размер буфера) и выходной (реальная длина)
	addrLenPtr := wasm.Malloc(4)
	if addrLenPtr == 0 {
		return &addr{address: l.address}
	}
	defer wasm.Free(addrLenPtr)

	// Записываем размер буфера (256) в addrLenPtr (входной параметр)
	bufferSizeBytes := make([]byte, 4)
	binary.LittleEndian.PutUint32(bufferSizeBytes, 256)
	wasm.ByteToPtr(bufferSizeBytes, addrLenPtr)

	// Вызываем host функцию
	ret := listener_addr(l.id, addrPtr, addrLenPtr)

	// Обрабатываем ошибку
	if err := wasm.HandleHostError(ret); err != nil {
		// При ошибке возвращаем кэшированный адрес
		return &addr{address: l.address}
	}

	// Читаем реальную длину адреса из addrLenPtr (выходной параметр)
	addrLenBytes := wasm.PtrToByte(addrLenPtr, 4)
	if len(addrLenBytes) < 4 {
		return &addr{address: l.address}
	}
	addrLen := binary.LittleEndian.Uint32(addrLenBytes)

	if addrLen == 0 {
		return &addr{address: l.address}
	}

	// Читаем адрес из памяти
	addrBytes := wasm.PtrToByte(addrPtr, addrLen)
	if len(addrBytes) == 0 {
		return &addr{address: l.address}
	}

	address := string(addrBytes)
	// Обновляем кэшированный адрес
	l.address = address
	return &addr{address: address}
}

// Accept ожидает и возвращает следующее соединение от слушателя.
// Блокирующая функция - ожидает появления нового соединения.
// Реализует интерфейс net.Listener.
func (l *Listener) Accept() (conn net.Conn, err error) {

	l.mu.Lock()
	if l.closed {
		l.mu.Unlock()
		return nil, fmt.Errorf(i18n.Msg("listener is closed"))
	}
	l.mu.Unlock()

	// Выделяем память для connID (4 байта для uint32)
	connIDPtr := wasm.Malloc(4)
	if connIDPtr == 0 {
		return nil, fmt.Errorf(i18n.Msg("failed to allocate memory for connID"))
	}
	defer wasm.Free(connIDPtr)

	// Вызываем host функцию (блокирующая)
	ret := listener_accept(l.id, connIDPtr)

	// Обрабатываем ошибку
	if err = wasm.HandleHostError(ret); err != nil {
		slog.Error(i18n.Msg("Listener.Accept: listener_accept failed"), slog.Uint64("listenerID", l.id), slog.String("error", err.Error()))
		return nil, err
	}

	// Читаем connID из памяти (little-endian uint32)
	connIDBytes := wasm.PtrToByte(connIDPtr, 4)
	if len(connIDBytes) < 4 {
		return nil, fmt.Errorf(i18n.Msg("invalid connID data size: expected 4, got %d"), len(connIDBytes))
	}

	connID := binary.LittleEndian.Uint32(connIDBytes)

	// Создаём Conn из connID
	return &Conn{
		id:      uint64(connID),
		network: NetworkTCP,
	}, nil
}

// Serve запускает цикл обработки соединений через callback.
// callbackName - имя экспортированной WASM функции для обработки соединений.
// Неблокирующая функция - возвращает управление сразу после запуска.
func (l *Listener) Serve(callbackName string) (err error) {

	l.mu.Lock()
	if l.serving {
		l.mu.Unlock()
		return fmt.Errorf(i18n.Msg("listener is already serving"))
	}
	l.serving = true
	l.mu.Unlock()

	// Преобразуем имя callback в указатель
	callbackPtr, callbackLen := wasm.StringToPtr(callbackName)
	defer wasm.Free(callbackPtr)

	// Вызываем host функцию (неблокирующая)
	ret := listener_serve_start(l.id, callbackPtr, callbackLen)

	// Обрабатываем ошибку
	if err = wasm.HandleHostError(ret); err != nil {
		slog.Error(i18n.Msg("Listener.Serve: listener_serve_start failed"), slog.Uint64("listenerID", l.id), slog.String("error", err.Error()))
		l.mu.Lock()
		l.serving = false
		l.mu.Unlock()
		return err
	}

	return nil
}

var _ net.Listener = (*Listener)(nil)
