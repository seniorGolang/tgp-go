//go:build wasip1

// GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.
package net

import (
	"io"
	"time"

	"tgp/core/wasm"
)

// getReadBufferPtr получает указатель на кольцевой буфер для чтения (хост → WASM).
// Кэширует результат в c.readBufferPtr.
func (c *Conn) getReadBufferPtr() (bufferPtr uint32, err error) {

	// Если уже кэширован, возвращаем кэшированное значение
	if c.readBufferPtrSet {
		return c.readBufferPtr, nil
	}

	// Выделяем память для bufferPtr (4 байта для uint32)
	bufferPtrPtr := wasm.Malloc(4)
	if bufferPtrPtr == 0 {
		return 0, io.ErrUnexpectedEOF
	}
	defer wasm.Free(bufferPtrPtr)

	// Вызываем host функцию для получения буфера чтения
	ret := conn_get_buffer_ptr(c.id, bufferPtrPtr)

	// Обрабатываем ошибку
	if err = wasm.HandleHostError(ret); err != nil {
		return 0, err
	}

	// Читаем bufferPtr из памяти (little-endian uint32)
	bufferPtrData := wasm.PtrToByte(bufferPtrPtr, 4)
	if len(bufferPtrData) < 4 {
		return 0, io.ErrUnexpectedEOF
	}

	// Парсим uint32 (little-endian)
	bufferPtr = uint32(bufferPtrData[0]) | uint32(bufferPtrData[1])<<8 | uint32(bufferPtrData[2])<<16 | uint32(bufferPtrData[3])<<24

	// Кэшируем результат
	c.readBufferPtr = bufferPtr
	c.readBufferPtrSet = true

	// Кэшируем DataSize при первом получении буфера
	if c.readBufferDataSize == 0 {
		var header wasm.RingBufferHeader
		if header, err = wasm.ReadRingBufferHeader(bufferPtr); err != nil {
			return 0, err
		}
		c.readBufferDataSize = header.DataSize
	}

	return bufferPtr, nil
}

// GetWriteBufferPtr получает указатель на кольцевой буфер для записи (WASM → хост).
// Кэширует результат в c.writeBufferPtr.
func (c *Conn) GetWriteBufferPtr() (bufferPtr uint32, err error) {

	// Если уже кэширован, возвращаем кэшированное значение
	if c.writeBufferPtrSet {
		return c.writeBufferPtr, nil
	}

	// Выделяем память для bufferPtr (4 байта для uint32)
	bufferPtrPtr := wasm.Malloc(4)
	if bufferPtrPtr == 0 {
		return 0, io.ErrUnexpectedEOF
	}
	defer wasm.Free(bufferPtrPtr)

	// Вызываем host функцию для получения буфера записи
	ret := conn_get_write_buffer_ptr(c.id, bufferPtrPtr)

	// Обрабатываем ошибку
	if err = wasm.HandleHostError(ret); err != nil {
		return 0, err
	}

	// Читаем bufferPtr из памяти (little-endian uint32)
	bufferPtrData := wasm.PtrToByte(bufferPtrPtr, 4)
	if len(bufferPtrData) < 4 {
		return 0, io.ErrUnexpectedEOF
	}

	// Парсим uint32 (little-endian)
	bufferPtr = uint32(bufferPtrData[0]) | uint32(bufferPtrData[1])<<8 | uint32(bufferPtrData[2])<<16 | uint32(bufferPtrData[3])<<24

	// Кэшируем результат
	c.writeBufferPtr = bufferPtr
	c.writeBufferPtrSet = true

	// Кэшируем DataSize при первом получении буфера
	if c.writeBufferDataSize == 0 {
		var header wasm.RingBufferHeader
		if header, err = wasm.ReadRingBufferHeader(bufferPtr); err != nil {
			return 0, err
		}
		c.writeBufferDataSize = header.DataSize
	}

	return bufferPtr, nil
}

// Read читает данные из соединения через кольцевой буфер.
// Блокирует до появления данных или до истечения deadline.
func (c *Conn) Read(b []byte) (n int, err error) {

	// Получаем указатель на кольцевой буфер для чтения (хост → WASM)
	var bufferPtr uint32
	if bufferPtr, err = c.getReadBufferPtr(); err != nil {
		return 0, err
	}

	// Определяем deadline для чтения
	var deadline time.Time
	if !c.readDeadline.IsZero() {
		deadline = c.readDeadline
	}

	// Блокируем чтение до появления данных или до истечения deadline
	n, err = wasm.AdaptivePollingRead(func() (ready bool, n int, err error) {
		readN, readErr := wasm.ReadFromRingBuffer(bufferPtr, c.readBufferDataSize, b)
		if readErr != nil {
			return false, readN, readErr
		}
		return readN > 0, readN, nil
	}, deadline)

	if err == nil && n > 0 {
		// Сбрасываем deadline после успешного чтения
		if !c.readDeadline.IsZero() {
			c.readDeadline = time.Time{}
		}
	}

	return n, err
}

// Write записывает данные в соединение через кольцевой буфер.
// Блокирует до появления места в буфере или до истечения deadline.
func (c *Conn) Write(b []byte) (n int, err error) {

	// Получаем указатель на кольцевой буфер для записи (WASM → хост)
	var bufferPtr uint32
	if bufferPtr, err = c.GetWriteBufferPtr(); err != nil {
		return 0, err
	}

	// Определяем deadline для записи
	var deadline time.Time
	if !c.writeDeadline.IsZero() {
		deadline = c.writeDeadline
	}

	// Записываем данные в кольцевой буфер для записи (WASM → хост)
	// Если буфер полон, блокируем до появления места или до истечения deadline
	totalWritten := 0
	for totalWritten < len(b) {
		var written int
		if written, err = wasm.WriteToRingBuffer(bufferPtr, c.writeBufferDataSize, b[totalWritten:]); err != nil {
			if err == io.EOF {
				return totalWritten, io.EOF
			}
			return totalWritten, err
		}

		if written > 0 {
			totalWritten += written
			continue
		}

		// Буфер полон, блокируем до появления места или до истечения deadline
		// ВАЖНО: bufio.Writer ожидает, что Write() либо запишет хотя бы 1 байт, либо вернет ошибку
		// Поэтому мы не возвращаем 0 без ошибки, а блокируем до появления места
		_, pollErr := wasm.AdaptivePollingRead(func() (ready bool, n int, err error) {
			// Проверяем, есть ли место для записи
			written, writeErr := wasm.WriteToRingBuffer(bufferPtr, c.writeBufferDataSize, b[totalWritten:])
			if writeErr != nil {
				return false, 0, writeErr
			}
			return written > 0, written, nil
		}, deadline)

		if pollErr != nil {
			return totalWritten, pollErr
		}
	}

	// Сбрасываем deadline после успешной записи
	if !c.writeDeadline.IsZero() {
		c.writeDeadline = time.Time{}
	}

	return totalWritten, nil
}

// Close закрывает соединение.
func (c *Conn) Close() (err error) {

	return wasm.CallHostUint64(conn_close, c.id)
}
