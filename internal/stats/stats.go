// Copyright (c) 2026 Khramtsov Aleksei (seniorGolang@gmail.com).
// conditions defined in file 'LICENSE', which is part of this project source code.

// GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.
package stats

import (
	"log/slog"
	"strings"

	"tgp/core/i18n"
	"tgp/internal/model"
)

const (
	TagServerJsonRPC = "jsonRPC-server"
	TagServerHTTP    = "http-server"
)

type ClientStats struct {
	ContractsToGenerate []*model.Contract
	ContractNames       []string
	JsonRPCCount        int
	HTTPCount           int
	TotalMethods        int
	TotalTypes          int
}

func CollectClientStats(project *model.Project) (stats ClientStats) {

	stats.ContractsToGenerate = make([]*model.Contract, 0)
	stats.ContractNames = make([]string, 0)

	for _, contract := range project.Contracts {
		hasJsonRPC := model.IsAnnotationSet(project, contract, nil, nil, TagServerJsonRPC)
		hasHTTP := model.IsAnnotationSet(project, contract, nil, nil, TagServerHTTP)

		if hasJsonRPC || hasHTTP {
			stats.ContractsToGenerate = append(stats.ContractsToGenerate, contract)
			stats.ContractNames = append(stats.ContractNames, contract.Name)
			stats.TotalMethods += len(contract.Methods)

			if hasJsonRPC {
				stats.JsonRPCCount++
			}
			if hasHTTP {
				stats.HTTPCount++
			}
		}
	}

	return
}

func (s ClientStats) ContractNamesString() (result string) {

	result = strings.Join(s.ContractNames, ", ")
	if len(s.ContractNames) == 0 {
		result = "нет контрактов"
	}
	return
}

type DocOptionsProvider interface {
	IsEnabled() bool
	GetFilePath() string
}

func StartGenerationAttrs(stats ClientStats, outDir string, docOpts DocOptionsProvider) (attrs []any) {

	attrs = []any{
		slog.String(i18n.Msg("contracts"), stats.ContractNamesString()),
		slog.Int(i18n.Msg("contracts count"), len(stats.ContractsToGenerate)),
		slog.String(i18n.Msg("output directory"), outDir),
	}

	// Добавляем информацию о типах серверов
	if stats.JsonRPCCount > 0 {
		attrs = append(attrs, slog.Int(i18n.Msg("jsonrpc contracts"), stats.JsonRPCCount))
	}
	if stats.HTTPCount > 0 {
		attrs = append(attrs, slog.Int(i18n.Msg("http contracts"), stats.HTTPCount))
	}

	// Добавляем информацию о документации
	if docOpts != nil && docOpts.IsEnabled() {
		attrs = append(attrs,
			slog.String(i18n.Msg("documentation"), i18n.Msg("documentation enabled")),
			slog.String(i18n.Msg("documentation file"), docOpts.GetFilePath()),
		)
	} else {
		attrs = append(attrs, slog.String(i18n.Msg("documentation"), i18n.Msg("documentation disabled")))
	}

	return
}

func (s *ClientStats) SetTotalTypes(totalTypes int) {

	s.TotalTypes = totalTypes
}

func CompleteGenerationAttrs(stats ClientStats, outDir string, docOpts DocOptionsProvider) (attrs []any) {

	attrs = []any{
		slog.Int(i18n.Msg("contracts count"), len(stats.ContractsToGenerate)),
		slog.Int(i18n.Msg("methods count"), stats.TotalMethods),
		slog.Int(i18n.Msg("types count"), stats.TotalTypes),
		slog.String(i18n.Msg("output directory"), outDir),
	}

	if stats.JsonRPCCount > 0 {
		attrs = append(attrs, slog.Int(i18n.Msg("jsonrpc contracts"), stats.JsonRPCCount))
	}
	if stats.HTTPCount > 0 {
		attrs = append(attrs, slog.Int(i18n.Msg("http contracts"), stats.HTTPCount))
	}

	if docOpts != nil && docOpts.IsEnabled() {
		attrs = append(attrs,
			slog.String(i18n.Msg("documentation"), i18n.Msg("documentation enabled")),
			slog.String(i18n.Msg("documentation file"), docOpts.GetFilePath()),
		)
	} else {
		attrs = append(attrs, slog.String(i18n.Msg("documentation"), i18n.Msg("documentation disabled")))
	}

	return
}

type SwaggerStats struct {
	ContractsToGenerate []*model.Contract
	ContractNames       []string
	TotalMethods        int
	TotalTypes          int
	FilteredContracts   []string
}

func CollectSwaggerStats(project *model.Project, filteredContracts []string) (stats SwaggerStats) {

	stats.ContractsToGenerate = make([]*model.Contract, 0)
	stats.ContractNames = make([]string, 0)
	stats.FilteredContracts = filteredContracts

	if len(filteredContracts) > 0 {
		for _, contract := range project.Contracts {
			for _, filterName := range filteredContracts {
				if contract.Name == filterName || contract.ID == filterName {
					stats.ContractsToGenerate = append(stats.ContractsToGenerate, contract)
					stats.ContractNames = append(stats.ContractNames, contract.Name)
					stats.TotalMethods += len(contract.Methods)
					break
				}
			}
		}
	} else {
		for _, contract := range project.Contracts {
			stats.ContractsToGenerate = append(stats.ContractsToGenerate, contract)
			stats.ContractNames = append(stats.ContractNames, contract.Name)
			stats.TotalMethods += len(contract.Methods)
		}
	}

	return
}

func (s SwaggerStats) ContractNamesString() (result string) {

	result = strings.Join(s.ContractNames, ", ")
	if len(s.ContractNames) == 0 {
		result = "нет контрактов"
	}
	return
}

func (s *SwaggerStats) SetTotalTypes(totalTypes int) {

	s.TotalTypes = totalTypes
}

func StartSwaggerGenerationAttrs(stats SwaggerStats, outFile string) (attrs []any) {

	attrs = []any{
		slog.String(i18n.Msg("contracts"), stats.ContractNamesString()),
		slog.Int(i18n.Msg("contracts count"), len(stats.ContractsToGenerate)),
		slog.String(i18n.Msg("output file"), outFile),
	}

	if len(stats.FilteredContracts) > 0 {
		attrs = append(attrs, slog.String(i18n.Msg("filtered contracts"), strings.Join(stats.FilteredContracts, ", ")))
	}

	return
}

func CompleteSwaggerGenerationAttrs(stats SwaggerStats, outFile string) (attrs []any) {

	attrs = []any{
		slog.Int(i18n.Msg("contracts count"), len(stats.ContractsToGenerate)),
		slog.Int(i18n.Msg("methods count"), stats.TotalMethods),
		slog.Int(i18n.Msg("types count"), stats.TotalTypes),
		slog.String(i18n.Msg("output file"), outFile),
	}

	return
}
