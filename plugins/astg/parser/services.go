// Copyright (c) 2026 Khramtsov Aleksei (seniorGolang@gmail.com).
// conditions defined in file 'LICENSE', which is part of this project source code.
package parser

import (
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"os"
	"path/filepath"
	"strings"

	"tgp/internal"
	"tgp/internal/model"
)

func findServices(project *model.Project, loader *AutonomousPackageLoader) (err error) {

	servicesMap := make(map[string]*model.Service)
	candidateFiles := make([]string, 0)

	err = filepath.Walk(internal.ProjectRoot, func(filePath string, info os.FileInfo, walkErr error) error {
		if walkErr != nil {
			return nil
		}

		if info.IsDir() {
			dirName := info.Name()
			if dirName == "vendor" || dirName == "node_modules" || dirName == ".git" ||
				dirName == ".tg" || dirName == "dist" || dirName == "build" {
				return filepath.SkipDir
			}
			if shouldExcludeDir(filePath, project.ExcludeDirs) {
				return filepath.SkipDir
			}
			return nil
		}

		if shouldExcludeDir(filepath.Dir(filePath), project.ExcludeDirs) {
			return nil
		}

		if !strings.HasSuffix(info.Name(), ".go") {
			return nil
		}

		if strings.HasSuffix(info.Name(), "_test.go") {
			return nil
		}

		if isGeneratedFile(filePath) {
			return nil
		}

		if hasMainFunction(filePath) {
			candidateFiles = append(candidateFiles, filePath)
		}

		return nil
	})

	if err != nil {
		return err
	}

	for _, filePath := range candidateFiles {
		fset := token.NewFileSet()
		var file *ast.File
		if file, err = parser.ParseFile(fset, filePath, nil, parser.ParseComments); err != nil {
			continue
		}

		var mainFunc *ast.FuncDecl
		for _, decl := range file.Decls {
			if fn, ok := decl.(*ast.FuncDecl); ok && fn.Name != nil && fn.Name.Name == "main" {
				mainFunc = fn
				break
			}
		}

		if mainFunc == nil {
			continue
		}

		if !isServiceMain(file, mainFunc, project, loader) {
			continue
		}

		serviceName := extractServiceName(filePath)
		mainPathRel := makeRelativePath(filePath)
		service := &model.Service{
			Name:        serviceName,
			MainPath:    mainPathRel,
			ContractIDs: make([]string, 0),
		}

		contractIDs := findContractsInMainFile(file, filePath, project, loader)
		service.ContractIDs = contractIDs

		servicesMap[filePath] = service
	}

	for _, service := range servicesMap {
		project.Services = append(project.Services, service)
	}

	return
}

func extractServiceName(mainPath string) (name string) {

	var relPath string
	var err error
	if relPath, err = filepath.Rel(internal.ProjectRoot, mainPath); err != nil {
		name = filepath.Base(filepath.Dir(mainPath))
		return
	}

	name = strings.TrimSuffix(filepath.Base(relPath), ".go")
	if name == "main" {
		name = filepath.Base(filepath.Dir(relPath))
	}

	return
}

func findContractsInMainFile(file *ast.File, filePath string, project *model.Project, loader *AutonomousPackageLoader) (contractIDs []string) {

	contractIDs = make([]string, 0)
	contractNames := make(map[string]*model.Contract)
	for _, contract := range project.Contracts {
		contractNames[contract.Name] = contract
	}

	importAliases := collectImports([]*ast.File{file})

	transportAliases := make(map[string]bool)
	for alias, impPath := range importAliases {
		if loader.HasVersionASTgConstant(impPath) {
			transportAliases[alias] = true
		}
	}

	ast.Inspect(file, func(n ast.Node) bool {
		if node, ok := n.(*ast.CallExpr); ok {
			if sel, ok := node.Fun.(*ast.SelectorExpr); ok {
				if transportAlias, ok := sel.X.(*ast.Ident); ok {
					if transportAliases[transportAlias.Name] {
						if contract, exists := contractNames[sel.Sel.Name]; exists {
							contractID := contract.ID
							found := false
							for _, id := range contractIDs {
								if id == contractID {
									found = true
									break
								}
							}
							if !found {
								contractIDs = append(contractIDs, contractID)
							}
						}
					}
				}
			}
		}
		return true
	})

	return
}

func isGeneratedFile(filePath string) (isGenerated bool) {

	var file *os.File
	var err error
	if file, err = os.Open(filePath); err != nil {
		return
	}
	defer file.Close()

	buf := make([]byte, 200)
	var n int
	n, _ = file.Read(buf)
	content := string(buf[:n])

	isGenerated = strings.Contains(content, "GENERATED BY 'T'ransport 'G'enerator. DO NOT EDIT.") ||
		strings.Contains(content, "GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.") ||
		strings.Contains(content, "This file is auto-generated. Do not edit manually.")
	return
}

func hasMainFunction(filePath string) (hasMain bool) {

	var file *os.File
	var err error
	if file, err = os.Open(filePath); err != nil {
		return
	}
	defer file.Close()

	buf := make([]byte, 8192)
	var n int
	if n, err = file.Read(buf); err != nil && err != io.EOF {
		return
	}

	content := string(buf[:n])
	patterns := []string{
		"func main(",
		"func main (",
		"func\tmain(",
		"func\nmain(",
		"func\r\nmain(",
	}

	for _, pattern := range patterns {
		if strings.Contains(content, pattern) {
			hasMain = true
			return
		}
	}

	return
}

func isServiceMain(file *ast.File, mainFunc *ast.FuncDecl, project *model.Project, loader *AutonomousPackageLoader) (isService bool) {

	contractNames := make(map[string]bool)
	for _, contract := range project.Contracts {
		contractNames[contract.Name] = true
	}

	importAliases := collectImports([]*ast.File{file})
	transportAliases := make(map[string]string)
	for alias, impPath := range importAliases {
		if loader.HasVersionASTgConstant(impPath) {
			transportAliases[alias] = impPath
		}
	}

	if len(transportAliases) == 0 {
		return false
	}

	transportAlias := ""
	for alias := range transportAliases {
		if isTransportUsedInMain(mainFunc, alias, contractNames) {
			transportAlias = alias
			break
		}
	}

	if transportAlias == "" {
		return false
	}

	hasServerCreation := false
	hasContractRegistration := false
	hasListenCall := false

	ast.Inspect(mainFunc.Body, func(n ast.Node) bool {
		if node, ok := n.(*ast.CallExpr); ok {
			if sel, ok := node.Fun.(*ast.SelectorExpr); ok {
				if x, ok := sel.X.(*ast.Ident); ok && x.Name == transportAlias {
					if sel.Sel.Name == "New" {
						hasServerCreation = true
						for _, arg := range node.Args {
							if checkContractRegistration(arg, contractNames, transportAlias) {
								hasContractRegistration = true
								break
							}
						}
					}
				}

				if x, ok := sel.X.(*ast.Ident); ok && x.Name == transportAlias {
					if contractNames[sel.Sel.Name] {
						hasContractRegistration = true
					}
				}

				methodName := sel.Sel.Name
				if methodName == "Listen" || methodName == "Serve" || methodName == "ServeMetrics" {
					hasListenCall = true
				}

				if _, ok := sel.X.(*ast.CallExpr); ok {
					if methodName == "Listen" || methodName == "Serve" {
						hasListenCall = true
					}
				}
			}
		}
		return true
	})

	isService = hasServerCreation && hasContractRegistration && hasListenCall
	return
}

func checkContractRegistration(node ast.Node, contractNames map[string]bool, transportAlias string) (isRegistration bool) {

	var callExpr *ast.CallExpr
	var ok bool
	if callExpr, ok = node.(*ast.CallExpr); !ok {
		var compLit *ast.CompositeLit
		if compLit, ok = node.(*ast.CompositeLit); ok {
			for _, elt := range compLit.Elts {
				if checkContractRegistration(elt, contractNames, transportAlias) {
					isRegistration = true
					return
				}
			}
		}
		return
	}

	var sel *ast.SelectorExpr
	if sel, ok = callExpr.Fun.(*ast.SelectorExpr); ok {
		var x *ast.Ident
		if x, ok = sel.X.(*ast.Ident); ok && x.Name == transportAlias {
			contractName := sel.Sel.Name
			if contractNames[contractName] {
				isRegistration = true
				return
			}
		}
	}

	return
}

func isTransportUsedInMain(mainFunc *ast.FuncDecl, alias string, contractNames map[string]bool) (isUsed bool) {

	hasNewCall := false
	hasContractCall := false

	ast.Inspect(mainFunc.Body, func(n ast.Node) bool {
		var callExpr *ast.CallExpr
		var ok bool
		if callExpr, ok = n.(*ast.CallExpr); ok {
			var sel *ast.SelectorExpr
			if sel, ok = callExpr.Fun.(*ast.SelectorExpr); ok {
				var x *ast.Ident
				if x, ok = sel.X.(*ast.Ident); ok && x.Name == alias {
					if sel.Sel.Name == "New" {
						hasNewCall = true
					}
					if contractNames[sel.Sel.Name] {
						hasContractCall = true
					}
				}
			}
		}
		return true
	})

	isUsed = hasNewCall && hasContractCall
	return
}

func shouldExcludeDir(dirPath string, excludeDirs []string) (shouldExclude bool) {

	if len(excludeDirs) == 0 {
		return
	}

	var relPath string
	var err error
	if relPath, err = filepath.Rel(internal.ProjectRoot, dirPath); err != nil {
		return
	}

	relPath = strings.TrimPrefix(relPath, "./")
	relPath = strings.TrimPrefix(relPath, ".\\")
	relPath = filepath.ToSlash(relPath)

	separator := "/"

	for _, excludeDir := range excludeDirs {
		excludeDir = strings.TrimPrefix(excludeDir, "./")
		excludeDir = strings.TrimPrefix(excludeDir, ".\\")
		excludeDir = filepath.ToSlash(excludeDir)

		if relPath == excludeDir {
			shouldExclude = true
			return
		}

		if strings.HasPrefix(relPath, excludeDir+separator) {
			shouldExclude = true
			return
		}
	}

	return
}
