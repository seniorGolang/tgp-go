//go:build wasip1

// GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.

package wasm

import (
	"encoding/binary"
	"fmt"

	"github.com/goccy/go-json"

	"tgp/core/i18n"
)

// hostInteractiveSelect вызывает функцию хоста для интерактивного выбора.
//
//go:wasmimport env host_interactive_select
func hostInteractiveSelect(promptPtr uint32, promptLen uint32, optionsPtr uint32, optionsLen uint32, configPtr uint32, configLen uint32, resultPtrPtr uint32, resultSizePtr uint32) (resultCode uint32)

// InteractiveSelect выполняет интерактивный выбор через хост.
// prompt - заголовок выбора
// options - список опций для выбора
// multiSelect - true для множественного выбора
// defaultOptions - опции, выбранные по умолчанию (для множественного выбора)
// Возвращает выбранные опции или ошибку.
func InteractiveSelect(prompt string, options []string, multiSelect bool, defaultOptions []string) (selected []string, err error) {

	// Кодируем options в JSON
	optionsJSONBytes, err := json.Marshal(options)
	if err != nil {
		return nil, fmt.Errorf(i18n.Msg("failed to encode options")+": %w", err)
	}

	// Кодируем config в JSON
	configJSON := interactiveSelectConfig{
		Prompt:         prompt,
		Options:        options,
		MultiSelect:    multiSelect,
		DefaultOptions: defaultOptions,
	}
	configJSONBytes, err := json.Marshal(configJSON)
	if err != nil {
		return nil, fmt.Errorf(i18n.Msg("failed to encode config")+": %w", err)
	}

	// Выделяем память для строк
	promptPtr, promptLen := StringToPtr(prompt)
	defer Free(promptPtr)

	optionsPtr, optionsLen := StringToPtr(string(optionsJSONBytes))
	defer Free(optionsPtr)

	configPtr, configLen := StringToPtr(string(configJSONBytes))
	defer Free(configPtr)

	// Выделяем память для указателей результата
	resultPtrPtr := Malloc(4)
	resultSizePtr := Malloc(4)
	defer Free(resultPtrPtr)
	defer Free(resultSizePtr)

	// Вызываем функцию хоста
	if hostInteractiveSelect(promptPtr, promptLen, optionsPtr, optionsLen, configPtr, configLen, resultPtrPtr, resultSizePtr) != 0 {
		return nil, fmt.Errorf(i18n.Msg("failed to execute interactive select"))
	}

	// Читаем указатель и размер результата
	resultPtr := ReadUint32(resultPtrPtr)
	resultSize := ReadUint32(resultSizePtr)

	if resultSize == 0 {
		return nil, fmt.Errorf(i18n.Msg("empty response from host"))
	}

	// Читаем результат
	resultBytes := PtrToByte(resultPtr, resultSize)
	defer Free(resultPtr)

	// Декодируем ответ из JSON
	var respJSON interactiveSelectResponse
	if err := json.Unmarshal(resultBytes, &respJSON); err != nil {
		return nil, fmt.Errorf(i18n.Msg("failed to decode response")+": %w", err)
	}

	if respJSON.Selected != nil {
		result := make([]string, 0, len(respJSON.Selected))
		for _, item := range respJSON.Selected {
			if str, ok := item.(string); ok {
				result = append(result, str)
			}
		}
		return result, nil
	}

	return nil, fmt.Errorf(i18n.Msg("invalid response format"))
}

// ReadUint32 читает uint32 из памяти WASM модуля (little-endian, 4 байта).
func ReadUint32(ptr uint32) (value uint32) {

	if ptr == 0 {
		return 0
	}

	data := PtrToByte(ptr, 4)
	if len(data) < 4 {
		return 0
	}

	return binary.LittleEndian.Uint32(data)
}

// WriteUint32 записывает uint32 в память WASM модуля (little-endian, 4 байта).
func WriteUint32(ptr uint32, value uint32) {

	if ptr == 0 {
		return
	}

	bytes := make([]byte, 4)
	binary.LittleEndian.PutUint32(bytes, value)
	ByteToPtr(bytes, ptr)
}
