//go:build wasip1

// GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.

package wasm

import (
	"fmt"

	"github.com/goccy/go-json"

	"tgp/core/i18n"
)

// exportWrapper создает стандартную обертку для экспорта функции.
// Автоматически обрабатывает ptr/size запроса, вызывает handler и упаковывает результат в uint64.
// Handler должен принимать десериализованный запрос и возвращать результат и ошибку.
func exportWrapper[TRequest any, TResult any](handler func(request TRequest) (result TResult, err error)) func(ptr uint32, size uint32) (result uint64) {

	return func(ptr uint32, size uint32) (result uint64) {

		// Читаем и десериализуем запрос
		requestBytes := PtrToByte(ptr, size)
		Free(ptr)

		var request TRequest
		if len(requestBytes) > 0 {
			if err := json.Unmarshal(requestBytes, &request); err != nil {
				errorBytes, _ := json.Marshal(map[string]string{
					"error": fmt.Sprintf(i18n.Msg("failed to unmarshal request")+": %v", err),
				})
				return createErrorResultFromBytes(errorBytes)
			}
		}

		// Вызываем handler
		response, err := handler(request)
		if err != nil {
			errorBytes, _ := json.Marshal(map[string]string{
				"error": err.Error(),
			})
			return createErrorResultFromBytes(errorBytes)
		}

		// Сериализуем ответ
		responseBytes, marshalErr := json.Marshal(response)
		if marshalErr != nil {
			errorBytes, _ := json.Marshal(map[string]string{
				"error": fmt.Sprintf(i18n.Msg("failed to marshal response")+": %v", marshalErr),
			})
			return createErrorResultFromBytes(errorBytes)
		}

		// Выделяем память для результата
		resultPtr, resultSize := byteToPtr(responseBytes)
		if resultPtr == 0 {
			errorBytes, _ := json.Marshal(map[string]string{
				"error": i18n.Msg("failed to allocate memory for result"),
			})
			return createErrorResultFromBytes(errorBytes)
		}

		// Возвращаем результат без флага ошибки
		return createSuccessResult(resultPtr, resultSize)
	}
}

// exportWrapperSimple создает обертку для экспорта функции без параметров.
// Handler должен возвращать только результат и ошибку.
func exportWrapperSimple[TResult any](handler func() (result TResult, err error)) func(ptr uint32, size uint32) (result uint64) {

	return func(ptr uint32, size uint32) (result uint64) {

		// Освобождаем память запроса (даже если он пустой)
		Free(ptr)

		// Вызываем handler
		response, err := handler()
		if err != nil {
			errorBytes, _ := json.Marshal(map[string]string{
				"error": err.Error(),
			})
			return createErrorResultFromBytes(errorBytes)
		}

		// Сериализуем ответ
		responseBytes, marshalErr := json.Marshal(response)
		if marshalErr != nil {
			errorBytes, _ := json.Marshal(map[string]string{
				"error": fmt.Sprintf(i18n.Msg("failed to marshal response")+": %v", marshalErr),
			})
			return createErrorResultFromBytes(errorBytes)
		}

		// Выделяем память для результата
		resultPtr, resultSize := byteToPtr(responseBytes)
		if resultPtr == 0 {
			errorBytes, _ := json.Marshal(map[string]string{
				"error": i18n.Msg("failed to allocate memory for result"),
			})
			return createErrorResultFromBytes(errorBytes)
		}

		// Возвращаем результат без флага ошибки
		return createSuccessResult(resultPtr, resultSize)
	}
}
