//go:build wasip1

// GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.
package http

import (
	"encoding/binary"
	"fmt"
	"io"
	"net/http"
	"net/url"

	"tgp/core/wasm"
)

// _dispatch обрабатывает один HTTP запрос.
// Вызывается хостом для обработки запроса из очереди.
//
//go:wasmexport _dispatch
func Dispatch() {

	// Выделяем память для request_id и handler_id
	requestIDPtr := wasm.Malloc(4)
	if requestIDPtr == 0 {
		return
	}
	defer wasm.Free(requestIDPtr)

	handlerIDPtr := wasm.Malloc(4)
	if handlerIDPtr == 0 {
		return
	}
	defer wasm.Free(handlerIDPtr)

	// Получаем следующий запрос из очереди
	ret := hostGetNextRequest(requestIDPtr, handlerIDPtr)
	if err := wasm.HandleHostError(ret); err != nil {
		// Ошибка получения запроса из очереди - просто возвращаемся
		return
	}

	// Читаем request_id и handler_id из памяти (uint32)
	requestIDBytes := wasm.PtrToByte(requestIDPtr, 4)
	if len(requestIDBytes) < 4 {
		return
	}
	requestID := uint64(binary.LittleEndian.Uint32(requestIDBytes))

	handlerIDBytes := wasm.PtrToByte(handlerIDPtr, 4)
	if len(handlerIDBytes) < 4 {
		return
	}
	handlerID := uint64(binary.LittleEndian.Uint32(handlerIDBytes))

	// Гарантируем, что host_finish_request будет вызван в любом случае
	defer func() {
		_ = hostFinishRequest(requestID)
	}()

	// Получаем обработчик по handler_id
	handler, ok := getHandler(handlerID)
	if !ok {
		// Обработчик не найден - завершаем обработку (host_finish_request вызовется в defer)
		return
	}

	// Получаем информацию о запросе
	req, err := getRequestInfo(requestID)
	if err != nil {
		// Ошибка получения информации о запросе - завершаем обработку (host_finish_request вызовется в defer)
		return
	}

	// Создаём ResponseWriter
	respWriter := newResponseWriter(requestID)

	// Вызываем обработчик
	handler.ServeHTTP(respWriter, req)

	// host_finish_request будет вызван в defer
}

// getRequestInfo получает информацию о запросе из хоста.
func getRequestInfo(requestID uint64) (req *http.Request, err error) {

	// Выделяем буфер для информации о запросе (64KB должно быть достаточно)
	infoBufSize := uint32(64 * 1024)
	infoBufPtr := wasm.Malloc(infoBufSize)
	if infoBufPtr == 0 {
		return nil, fmt.Errorf("failed to allocate memory for request info")
	}
	defer wasm.Free(infoBufPtr)

	// Получаем информацию о запросе
	ret := hostGetRequestInfo(requestID, infoBufPtr, infoBufSize)
	// Проверяем ошибку через HandleHostError
	if err := wasm.HandleHostError(ret); err != nil {
		return nil, fmt.Errorf("failed to get request info: %w", err)
	}
	// Если ret == 0, это ошибка (нет данных)
	if ret == 0 {
		return nil, fmt.Errorf("failed to get request info: no data written")
	}
	// ret содержит количество записанных байт (без флага ошибки)
	bytesWritten := uint32(ret)
	if bytesWritten == 0 {
		return nil, fmt.Errorf("failed to get request info: no data written")
	}

	// Читаем данные из буфера
	infoBytes := wasm.PtrToByte(infoBufPtr, bytesWritten)

	// Парсим информацию о запросе
	offset := 0

	// Читаем method_len и method
	if offset+4 > len(infoBytes) {
		return nil, fmt.Errorf("invalid request info: method_len")
	}
	methodLen := int(binary.LittleEndian.Uint32(infoBytes[offset : offset+4]))
	offset += 4

	if offset+methodLen > len(infoBytes) {
		return nil, fmt.Errorf("invalid request info: method")
	}
	method := string(infoBytes[offset : offset+methodLen])
	offset += methodLen

	// Читаем url_len и url
	if offset+4 > len(infoBytes) {
		return nil, fmt.Errorf("invalid request info: url_len")
	}
	urlLen := int(binary.LittleEndian.Uint32(infoBytes[offset : offset+4]))
	offset += 4

	if offset+urlLen > len(infoBytes) {
		return nil, fmt.Errorf("invalid request info: url")
	}
	urlStr := string(infoBytes[offset : offset+urlLen])
	offset += urlLen

	// Парсим URL
	parsedURL, parseErr := url.Parse(urlStr)
	if parseErr != nil {
		return nil, fmt.Errorf("failed to parse URL: %w", parseErr)
	}

	// Читаем headers_count
	if offset+4 > len(infoBytes) {
		return nil, fmt.Errorf("invalid request info: headers_count")
	}
	headerCount := int(binary.LittleEndian.Uint32(infoBytes[offset : offset+4]))
	offset += 4

	// Читаем заголовки
	header := make(http.Header)
	for i := 0; i < headerCount; i++ {
		// Читаем key_len и key
		if offset+4 > len(infoBytes) {
			break
		}
		keyLen := int(binary.LittleEndian.Uint32(infoBytes[offset : offset+4]))
		offset += 4

		if offset+keyLen > len(infoBytes) {
			break
		}
		key := string(infoBytes[offset : offset+keyLen])
		offset += keyLen

		// Читаем value_len и value
		if offset+4 > len(infoBytes) {
			break
		}
		valueLen := int(binary.LittleEndian.Uint32(infoBytes[offset : offset+4]))
		offset += 4

		if offset+valueLen > len(infoBytes) {
			break
		}
		value := string(infoBytes[offset : offset+valueLen])
		offset += valueLen

		header.Add(key, value)
	}

	// Создаём Request
	req = &http.Request{
		Method: method,
		URL:    parsedURL,
		Header: header,
		Body:   &requestBody{requestID: requestID},
	}

	return req, nil
}

// requestBody реализует io.ReadCloser для чтения тела запроса через хост-функции.
type requestBody struct {
	requestID uint64
}

func (rb *requestBody) Read(p []byte) (n int, err error) {

	if len(p) == 0 {
		return 0, nil
	}

	// Выделяем память для буфера
	bufPtr := wasm.Malloc(uint32(len(p)))
	if bufPtr == 0 {
		return 0, fmt.Errorf("failed to allocate memory for request body")
	}
	defer wasm.Free(bufPtr)

	// Читаем данные через хост-функцию
	ret := hostReadRequestBody(rb.requestID, bufPtr, uint32(len(p)))
	// Проверяем ошибку через HandleHostError
	if err := wasm.HandleHostError(ret); err != nil {
		return 0, fmt.Errorf("failed to read request body: %w", err)
	}
	bytesRead := uint32(ret)

	if bytesRead == 0 {
		return 0, io.EOF
	}

	// Копируем данные из WASM памяти в буфер
	buf := wasm.PtrToByte(bufPtr, bytesRead)
	copy(p, buf)

	return int(bytesRead), nil
}

func (rb *requestBody) Close() (err error) {

	return nil
}

// httpResponseWriter реализует http.ResponseWriter для записи ответа через хост-функции.
type httpResponseWriter struct {
	requestID  uint64
	header     http.Header
	statusCode int
	written    bool
}

func newResponseWriter(requestID uint64) (w *httpResponseWriter) {

	return &httpResponseWriter{
		requestID:  requestID,
		header:     make(http.Header),
		statusCode: 0,
		written:    false,
	}
}

func (w *httpResponseWriter) Header() (header http.Header) {

	return w.header
}

func (w *httpResponseWriter) Write(data []byte) (n int, err error) {

	// Если статус ещё не отправлен, отправляем его
	if !w.written {
		w.WriteHeader(http.StatusOK)
	}

	// Выделяем память для данных (используем неэкспортированную функцию byteToPtr через обертку)
	// Создаём временный буфер и копируем данные
	bufPtr := wasm.Malloc(uint32(len(data)))
	if bufPtr == 0 {
		return 0, fmt.Errorf("failed to allocate memory for response body")
	}
	defer wasm.Free(bufPtr)

	// Копируем данные в WASM память
	wasm.ByteToPtr(data, bufPtr)
	dataPtr := bufPtr
	dataLen := uint32(len(data))

	// Записываем данные через хост-функцию
	ret := hostWriteResponseBody(w.requestID, dataPtr, dataLen)
	// Проверяем ошибку через HandleHostError
	if err := wasm.HandleHostError(ret); err != nil {
		return 0, fmt.Errorf("failed to write response body: %w", err)
	}
	// ret содержит количество записанных байт (без флага ошибки)
	bytesWritten := uint32(ret)

	return int(bytesWritten), nil
}

func (w *httpResponseWriter) WriteHeader(statusCode int) {

	if w.written {
		return
	}

	w.statusCode = statusCode
	w.written = true

	// Сериализуем заголовки
	headersBuf := make([]byte, 0, 1024)
	for key, values := range w.header {
		keyBytes := []byte(key)
		for _, value := range values {
			valueBytes := []byte(value)

			// key_len и key
			keyLenBytes := make([]byte, 4)
			binary.LittleEndian.PutUint32(keyLenBytes, uint32(len(keyBytes)))
			headersBuf = append(headersBuf, keyLenBytes...)
			headersBuf = append(headersBuf, keyBytes...)

			// value_len и value
			valueLenBytes := make([]byte, 4)
			binary.LittleEndian.PutUint32(valueLenBytes, uint32(len(valueBytes)))
			headersBuf = append(headersBuf, valueLenBytes...)
			headersBuf = append(headersBuf, valueBytes...)
		}
	}

	// Выделяем память для заголовков
	headersPtr := wasm.Malloc(uint32(len(headersBuf)))
	if headersPtr == 0 {
		return
	}
	defer wasm.Free(headersPtr)

	// Копируем данные в WASM память
	wasm.ByteToPtr(headersBuf, headersPtr)
	headersLen := uint32(len(headersBuf))

	// Записываем заголовки и статус через хост-функцию
	ret := hostWriteResponseHeaders(w.requestID, int32(statusCode), headersPtr, headersLen)
	// Проверяем ошибку через HandleHostError
	if err := wasm.HandleHostError(ret); err != nil {
		// Ошибка записи заголовков - игнорируем, так как статус уже установлен
		_ = err
	}
}
