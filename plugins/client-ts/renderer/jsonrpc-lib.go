// Copyright (c) 2026 Khramtsov Aleksei (seniorGolang@gmail.com).
// conditions defined in file 'LICENSE', which is part of this project source code.
package renderer

import (
	"fmt"
	"os"
	"path"

	"tgp/plugins/client-ts/tsg"
)

func (r *ClientRenderer) RenderJsonRPCLibrary() error {
	outDir := r.outDir

	// Создаем директорию jsonrpc
	jsonrpcDir := path.Join(outDir, "jsonrpc")
	if err := os.MkdirAll(jsonrpcDir, 0755); err != nil {
		return fmt.Errorf("failed to create jsonrpc directory: %w", err)
	}

	// Создаем директорию jsonrpc/utils
	utilsDir := path.Join(jsonrpcDir, "utils")
	if err := os.MkdirAll(utilsDir, 0755); err != nil {
		return fmt.Errorf("failed to create jsonrpc/utils directory: %w", err)
	}

	if err := r.renderJsonRPCClient(jsonrpcDir); err != nil {
		return err
	}

	if err := r.renderJsonRPCUtils(utilsDir); err != nil {
		return err
	}

	if err := r.renderJsonRPCTsUtils(utilsDir); err != nil {
		return err
	}

	return nil
}

func (r *ClientRenderer) renderJsonRPCClient(jsonrpcDir string) error {
	file := tsg.NewFile()
	file.Comment("// GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.\n")

	// Импорты
	file.ImportType("./utils/jsonrpc", "RequestRPC", "ResponseRPC", "ID")

	// Импорты
	file.ImportNamed("../options", "ClientOptions")

	classStmt := tsg.NewStatement().
		Comment("JSON-RPC 2.0 client").
		Export().Class("JsonRpcClient", func(grp *tsg.Group) {
		// Приватные поля
		grp.Add(tsg.NewStatement().Private().Id("options").Colon().Id("ClientOptions").Semicolon())
		grp.Line()

		// Конструктор
		constructor := tsg.NewStatement().
			Id("constructor").
			Params(func(cg *tsg.Group) {
				cg.Add(tsg.NewStatement().Id("options").Colon().Id("ClientOptions"))
			}).
			BlockFunc(func(cg *tsg.Group) {
				cg.Add(tsg.NewStatement().
					This().
					Dot("options").
					Op("=").
					Id("options").
					Semicolon())
			})
		grp.Add(constructor)
		grp.Line()

		// Публичный метод для генерации ID
		generateIdStmt := tsg.NewStatement().
			Id("generateId").
			Call().
			Colon().
			Id("string").
			BlockFunc(func(mg *tsg.Group) {
				mg.Add(tsg.NewStatement().
					Return().
					Id("this.options.idGeneratorFn").
					Op("?").
					Id("this.options.idGeneratorFn").
					Call().
					Colon().
					Id("crypto").
					Dot("randomUUID").
					Call().
					Semicolon())
			})
		grp.Add(generateIdStmt)
		grp.Line()

		// Приватный метод для получения заголовков (поддерживает статичные и динамические)
		getHeadersMethod := tsg.NewStatement().
			Comment("Gets headers for the request, supporting both static headers and dynamic header functions").
			Private().
			AsyncMethodWithParams("getHeaders", nil, tsg.NewStatement().Id("Record").Generic("string", "string"), func(mg *tsg.Group) {
				mg.If(
					tsg.NewStatement().Id("this").Dot("options").Dot("headers").Op("&&").Id("typeof").Call(tsg.NewStatement().Id("this").Dot("options").Dot("headers")).Op("===").Lit("function"),
					func(ig *tsg.Group) {
						// Если это функция, вызываем её (async функция автоматически обернет Promise)
						ig.Return(tsg.NewStatement().Id("this").Dot("options").Dot("headers").Call())
					},
				)
				// Иначе возвращаем статичные заголовки или пустой объект
				mg.If(
					tsg.NewStatement().Id("this").Dot("options").Dot("headers").Op("&&").Id("typeof").Call(tsg.NewStatement().Id("this").Dot("options").Dot("headers")).Op("!==").Lit("function"),
					func(ig *tsg.Group) {
						ig.Return(tsg.NewStatement().Id("this").Dot("options").Dot("headers").Op("as").Id("Record").Generic("string", "string"))
					},
				)
				// Если ничего не подошло, возвращаем пустой объект
				mg.Return(tsg.NewStatement().ObjectLiteral(nil))
			})
		grp.Add(getHeadersMethod)
		grp.Line()

		// Метод call для одиночного запроса
		callMethodParams := tsg.NewStatement().
			Params(func(pg *tsg.Group) {
				pg.Add(tsg.NewStatement().Id("method").Colon().Id("string"))
				pg.Add(tsg.NewStatement().Id("params").Optional().Colon().Id("any"))
			})
		callReturnType := tsg.NewStatement().
			ObjectLiteral(func(og *tsg.Group) {
				og.Add(tsg.NewStatement().ObjectField("type", tsg.NewStatement().Union(
					tsg.NewStatement().Lit("success"),
					tsg.NewStatement().Lit("error"),
				)))
				og.Add(tsg.NewStatement().OptionalField("result", tsg.NewStatement().Any()))
				og.Add(tsg.NewStatement().OptionalField("error", tsg.NewStatement().Any()))
			})
		callMethod := tsg.NewStatement().
			Comment("Calls a JSON-RPC method").
			AsyncMethodWithParams("exec", callMethodParams, callReturnType, func(bg *tsg.Group) {
				idGen := tsg.NewStatement().
					Const("id").
					Op("=").
					Id("this.options.idGeneratorFn").
					Op("?").
					Id("this.options.idGeneratorFn").
					Call().
					Colon().
					Id("crypto").
					Dot("randomUUID").
					Call().
					Semicolon()
				bg.Add(idGen)

				// Создаем запрос
				requestStmt := tsg.NewStatement().
					Const("request").
					Colon().
					Id("any").
					Op("=").
					ObjectLiteral(func(og *tsg.Group) {
						og.Add(tsg.NewStatement().ObjectField("jsonrpc", tsg.NewStatement().Lit("2.0")))
						og.Add(tsg.NewStatement().ObjectField("method", tsg.NewStatement().Id("method")))
						og.Add(tsg.NewStatement().ObjectField("params", tsg.NewStatement().Id("params").Op("||").ObjectLiteral(nil)))
						og.Add(tsg.NewStatement().ObjectField("id", tsg.NewStatement().Id("id")))
					}).
					Semicolon()
				bg.Add(requestStmt)

				headersVar := tsg.NewStatement().
					Const("headers").
					Colon().
					Id("Record").
					Generic("string", "string").
					Op("=").
					Await(tsg.NewStatement().This().Dot("getHeaders").Call()).
					Semicolon()
				bg.Add(headersVar)

				// Выполняем запрос
				fetchCall := tsg.NewStatement().
					Const("response").
					Colon().
					Id("Response").
					Op("=").
					Await(
						tsg.NewStatement().
							Id("fetch").
							Call(
								tsg.NewStatement().Id("this.options.url"),
								tsg.NewStatement().ObjectLiteral(func(og *tsg.Group) {
									og.Add(tsg.NewStatement().ObjectField("method", tsg.NewStatement().Lit("POST")))
									og.Add(tsg.NewStatement().ObjectField("headers", tsg.NewStatement().ObjectLiteral(func(hg *tsg.Group) {
										hg.Add(tsg.NewStatement().ObjectField("Content-Type", tsg.NewStatement().Lit("application/json")))
										hg.Add(tsg.NewStatement().Spread(tsg.NewStatement().Id("headers")))
									})))
									og.Add(tsg.NewStatement().ObjectField("body", tsg.NewStatement().Id("JSON.stringify").Call(tsg.NewStatement().Id("request"))))
								}),
							),
					).
					Semicolon()
				bg.Add(fetchCall)

				bg.If(
					tsg.NewStatement().Op("!").Id("response").Dot("ok"),
					func(ig *tsg.Group) {
						ig.Throw(tsg.NewStatement().
							New("Error").
							Call(tsg.NewStatement().Lit("HTTP error: ").Op("+").Id("response.status")))
					},
				)

				// Парсим ответ
				parse := tsg.NewStatement().
					Const("data").
					Colon().
					Id("any").
					Op("=").
					Await(tsg.NewStatement().Id("response").Dot("json").Call()).
					Semicolon()
				bg.Add(parse)

				bg.If(
					tsg.NewStatement().Id("data.error"),
					func(ig *tsg.Group) {
						ig.Return(tsg.NewStatement().ObjectLiteral(func(og *tsg.Group) {
							og.Add(tsg.NewStatement().ObjectField("type", tsg.NewStatement().Lit("error")))
							og.Add(tsg.NewStatement().ObjectField("error", tsg.NewStatement().Id("data.error")))
						}))
					},
				)

				// Возвращаем результат в формате {type: 'success', result}
				bg.Return(tsg.NewStatement().ObjectLiteral(func(og *tsg.Group) {
					og.Add(tsg.NewStatement().ObjectField("type", tsg.NewStatement().Lit("success")))
					og.Add(tsg.NewStatement().ObjectField("result", tsg.NewStatement().Id("data.result")))
				}))
			})
		grp.Add(callMethod)
		grp.Line()

		// Метод callBatch для batch запросов
		batchParams := tsg.NewStatement().
			Params(func(pg *tsg.Group) {
				pg.Add(tsg.NewStatement().Id("requests").Colon().ReadonlyArray(tsg.NewStatement().Id("RequestRPC")))
			})
		batchReturnType := tsg.NewStatement().
			Nullable(tsg.NewStatement().Id("Map").Generic("ID", "ResponseRPC"))
		batchMethod := tsg.NewStatement().
			Comment("Calls multiple JSON-RPC methods in a single request").
			Comment("@returns Map with response ID as key and ResponseRPC as value, or null on error").
			AsyncMethodWithParams("callBatch", batchParams, batchReturnType, func(bg *tsg.Group) {
				headersVar := tsg.NewStatement().
					Const("headers").
					Colon().
					Id("Record").
					Generic("string", "string").
					Op("=").
					Await(tsg.NewStatement().This().Dot("getHeaders").Call()).
					Semicolon()
				bg.Add(headersVar)

				// Выполняем запрос
				fetchCall := tsg.NewStatement().
					Const("response").
					Colon().
					Id("Response").
					Op("=").
					Await(
						tsg.NewStatement().
							Id("fetch").
							Call(
								tsg.NewStatement().Id("this.options.url"),
								tsg.NewStatement().ObjectLiteral(func(og *tsg.Group) {
									og.Add(tsg.NewStatement().ObjectField("method", tsg.NewStatement().Lit("POST")))
									og.Add(tsg.NewStatement().ObjectField("headers", tsg.NewStatement().ObjectLiteral(func(hg *tsg.Group) {
										hg.Add(tsg.NewStatement().ObjectField("Content-Type", tsg.NewStatement().Lit("application/json")))
										hg.Add(tsg.NewStatement().Spread(tsg.NewStatement().Id("headers")))
									})))
									og.Add(tsg.NewStatement().ObjectField("body", tsg.NewStatement().Id("JSON.stringify").Call(tsg.NewStatement().Id("requests"))))
								}),
							),
					).
					Semicolon()
				bg.Add(fetchCall)

				bg.If(
					tsg.NewStatement().Op("!").Id("response").Dot("ok"),
					func(ig *tsg.Group) {
						ig.Return(tsg.NewStatement().Id("null"))
					},
				)

				// Парсим ответ
				parse := tsg.NewStatement().
					Const("data").
					Colon().
					Id("ResponseRPC[]").
					Op("=").
					Await(tsg.NewStatement().Id("response").Dot("json").Call()).
					Semicolon()
				bg.Add(parse)

				mapStmt := tsg.NewStatement().
					Const("responseMap").
					Colon().
					Id("Map").
					Generic("ID", "ResponseRPC").
					Op("=").
					New("Map").
					Generic("ID", "ResponseRPC").
					Call().
					Semicolon()
				bg.Add(mapStmt)

				// Заполняем Map
				forLoop := tsg.NewStatement().
					ForOf("resp", "data", func(fg *tsg.Group) {
						fg.Add(tsg.NewStatement().
							Id("responseMap").
							Dot("set").
							Call(
								tsg.NewStatement().Id("resp.id"),
								tsg.NewStatement().Id("resp"),
							))
					})
				bg.Add(forLoop)

				// Возвращаем Map
				bg.Return(tsg.NewStatement().Id("responseMap"))
			})
		grp.Add(batchMethod)
	})
	file.Add(classStmt)
	file.Line()

	file.GenerateImports()

	return file.Save(path.Join(jsonrpcDir, "client.ts"))
}

func (r *ClientRenderer) renderJsonRPCUtils(utilsDir string) error {
	file := tsg.NewFile()
	file.Comment("// GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.\n")

	// Тип ID
	stmt1 := tsg.NewStatement()
	stmt1.Export().Type("ID").Op("=").Id("string").Op("|").Id("number").Semicolon()
	file.Add(stmt1)
	file.Line()

	// Тип JsonRpcParams
	stmt2 := tsg.NewStatement()
	stmt2.Export().Type("JsonRpcParams").Op("=").Id("any").Semicolon()
	file.Add(stmt2)
	file.Line()

	// Тип RequestRPC
	stmt3 := tsg.NewStatement()
	stmt3.Export().Interface("RequestRPC", func(grp *tsg.Group) {
		grp.Add(tsg.NewStatement().Id("jsonrpc").Colon().Lit("2.0").Semicolon())
		grp.Add(tsg.NewStatement().Id("method").Colon().Id("string").Semicolon())
		grp.Add(tsg.NewStatement().Id("params").Optional().Colon().Id("JsonRpcParams").Semicolon())
		grp.Add(tsg.NewStatement().Id("id").Colon().Id("ID").Semicolon())
	})
	file.Add(stmt3)
	file.Line()

	// Тип ResponseRPC
	stmt4 := tsg.NewStatement()
	stmt4.Export().Interface("ResponseRPC", func(grp *tsg.Group) {
		grp.Add(tsg.NewStatement().Id("jsonrpc").Colon().Lit("2.0").Semicolon())
		grp.Add(tsg.NewStatement().Id("result").Optional().Colon().Id("any").Semicolon())
		grp.Add(tsg.NewStatement().Id("error").Optional().Colon().Id("any").Semicolon())
		grp.Add(tsg.NewStatement().Id("id").Colon().Id("ID").Semicolon())
	})
	file.Add(stmt4)
	file.Line()

	// Тип JsonRpcCall
	stmt5 := tsg.NewStatement()
	stmt5.Export().Type("JsonRpcCall")
	stmt5.Generic("Params extends JsonRpcParams")
	stmt5.Op("=")
	stmt5.BlockFunc(func(grp *tsg.Group) {
		grp.Add(tsg.NewStatement().Id("jsonrpc").Colon().Lit("2.0").Semicolon())
		grp.Add(tsg.NewStatement().Id("method").Colon().Id("string").Semicolon())
		grp.Add(tsg.NewStatement().Id("params").Optional().Colon().Id("Params").Semicolon())
		grp.Add(tsg.NewStatement().Id("id").Colon().Id("ID").Semicolon())
	})
	stmt5.Semicolon()
	file.Add(stmt5)
	file.Line()

	file.GenerateImports()

	return file.Save(path.Join(utilsDir, "jsonrpc.ts"))
}

func (r *ClientRenderer) renderJsonRPCTsUtils(utilsDir string) error {
	file := tsg.NewFile()
	file.Comment("// GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.\n")

	// Импорты
	file.ImportType("./jsonrpc", "JsonRpcCall", "JsonRpcParams")

	// Тип MapBatchResult
	stmt := tsg.NewStatement()
	stmt.Export().Type("MapBatchResult")
	stmt.Generic("Calls extends readonly JsonRpcCall<JsonRpcParams>[]")
	stmt.Op("=")
	// Mapped type для MapBatchResult - используем TypeFromString, так как это сложная конструкция типа
	mapResultStmt := tsg.TypeFromString("{ readonly [K in keyof Calls]: Calls[K] extends JsonRpcCall<infer Params> ? JsonRpcCall<Params> : never }")
	stmt.Add(mapResultStmt)
	stmt.Semicolon()
	file.Add(stmt)
	file.Line()

	file.GenerateImports()

	return file.Save(path.Join(utilsDir, "ts.ts"))
}
