// Code generated by astg plugin. DO NOT EDIT.
// This file contains autonomous types from internal/tags package.
package astg

import (
	"encoding/json"
	"fmt"
	"strconv"
	"strings"
)

const (
	// Mark is the annotation mark used in Go comments.
	Mark = "@tg"
)

// DocTags represents a map of annotation tags.
type DocTags map[string]string

// MarshalJSON implements json.Marshaler interface.
func (tags DocTags) MarshalJSON() (bytes []byte, err error) {

	if len(tags) == 0 {
		return json.Marshal(nil)
	}
	// Преобразуем map[string]string в map[string]any
	// Пустые строки заменяем на true (булево значение)
	result := make(map[string]any)
	for k, v := range tags {
		if v == "" {
			result[k] = true
		} else {
			result[k] = v
		}
	}
	return json.Marshal(result)
}

// UnmarshalJSON implements json.Unmarshaler interface.
func (tags *DocTags) UnmarshalJSON(data []byte) error {
	// Десериализуем в map[string]any, чтобы обработать булевы значения
	var raw map[string]any
	if err := json.Unmarshal(data, &raw); err != nil {
		return err
	}

	if tags == nil {
		*tags = make(DocTags)
	}
	if *tags == nil {
		*tags = make(DocTags)
	}

	// Преобразуем обратно в map[string]string
	// Булевы true заменяем на пустую строку
	for k, v := range raw {
		switch val := v.(type) {
		case bool:
			if val {
				(*tags)[k] = ""
			} else {
				(*tags)[k] = "false"
			}
		case string:
			(*tags)[k] = val
		default:
			// Для других типов преобразуем в строку
			(*tags)[k] = fmt.Sprintf("%v", val)
		}
	}

	return nil
}

// Merge объединяет теги из другого DocTags в текущий.
func (tags DocTags) Merge(t DocTags) DocTags {

	if tags == nil {
		tags = make(DocTags)
	}

	for k, v := range t {
		tags[k] = v
	}
	return tags
}

// ParseTags парсит аннотации из документации.
func ParseTags(docs []string) (tags DocTags) {

	tags = make(DocTags)

	textLines := make(map[string][]string)

	for _, doc := range docs {

		doc = strings.TrimSpace(strings.TrimPrefix(doc, "//"))

		if strings.HasPrefix(doc, Mark) {

			values, _ := TagScanner(doc[len(Mark):])

			for k, v := range values {

				if _, found := tags[k]; found {
					tags[k] += "," + v
				} else {
					tags[k] = v
				}
			}
		}
	}

	for key, value := range tags {

		if !strings.HasPrefix(value, "#") {
			continue
		}

		for textKey, text := range textLines {
			if value == textKey {
				tags[key] = strings.Join(text, "\n")
			}
		}
	}
	return
}

// IsSet проверяет, установлен ли тег.
func (tags DocTags) IsSet(tagName string) (found bool) {
	_, found = tags[tagName]
	return
}

// Contains проверяет, содержит ли DocTags ключ, содержащий указанное слово.
func (tags DocTags) Contains(word string) (found bool) {

	for key := range tags {
		if strings.Contains(key, word) {
			return true
		}
	}
	return
}

// ToDocs преобразует DocTags обратно в строки документации.
func (tags DocTags) ToDocs() (docs []string) {

	for key, value := range tags {
		docs = append(docs, fmt.Sprintf("// %s %s=`%v`", Mark, key, value))
	}
	return
}

// Sub возвращает подмножество тегов с указанным префиксом.
func (tags DocTags) Sub(prefix string) (subTags DocTags) {

	prefix += "."
	subTags = make(DocTags)
	for key, value := range tags {
		if strings.HasPrefix(key, prefix) {
			subTags[strings.TrimPrefix(key, prefix)] = value
		}
	}
	return
}

// Set устанавливает значение тега.
func (tags DocTags) Set(tagName string, values ...string) {
	tags[tagName] = strings.Join(values, ",")
}

// Value возвращает значение тега или значение по умолчанию.
func (tags DocTags) Value(tagName string, defValue ...string) (value string) {

	var found bool
	if value, found = tags[tagName]; !found {
		value = strings.Join(defValue, " ")
	}
	return
}

// ValueInt возвращает значение тега как int или значение по умолчанию.
func (tags DocTags) ValueInt(tagName string, defValue ...int) (value int) {

	if len(defValue) != 0 {
		value = defValue[0]
	}
	if textValue, found := tags[tagName]; found {
		if newValue, err := strconv.Atoi(textValue); err == nil {
			return newValue
		}
	}
	return
}

// ValueBool возвращает значение тега как bool или значение по умолчанию.
func (tags DocTags) ValueBool(tagName string, defValue ...bool) (value bool) {

	if len(defValue) != 0 {
		value = defValue[0]
	}
	if textValue, found := tags[tagName]; found {
		if newValue, err := strconv.ParseBool(textValue); err == nil {
			return newValue
		}
	}
	return
}

// ToKeys преобразует значение тега в map[string]int, используя разделитель.
func (tags DocTags) ToKeys(tagName, separator string, defValue ...string) map[string]int {
	slice := strings.Split(tags.Value(tagName, defValue...), separator)
	m := make(map[string]int)
	for i, v := range slice {
		m[v] = i
	}
	return m
}

// ToMap преобразует значение тега в map[string]string.
func (tags DocTags) ToMap(tagName, separator, splitter string, defValue ...string) (m map[string]string) {

	m = make(map[string]string)

	pairs := strings.Split(tags.Value(tagName, defValue...), separator)

	for _, pair := range pairs {
		if kv := strings.Split(pair, splitter); len(kv) == 2 {
			m[kv[0]] = kv[1]
		}
	}
	return
}
