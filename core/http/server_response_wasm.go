//go:build wasip1

// GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.
package http

import (
	"bufio"
	"fmt"
	"net"
	"net/http"
)

const (
	// httpVersion - версия HTTP протокола
	httpVersion = "HTTP/1.1"
)

// responseWriter реализует http.ResponseWriter для записи HTTP ответа в net.Conn.
type responseWriter struct {
	conn       net.Conn
	writer     *bufio.Writer
	header     http.Header
	statusCode int
	written    bool
}

func (w *responseWriter) Header() (header http.Header) {

	return w.header
}

func (w *responseWriter) Write(data []byte) (n int, err error) {

	// Если статус ещё не отправлен, отправляем его
	if !w.written {
		w.WriteHeader(http.StatusOK)
	}

	return w.writer.Write(data)
}

func (w *responseWriter) WriteHeader(statusCode int) {

	if w.written {
		return
	}

	w.statusCode = statusCode
	w.written = true

	// Записываем статусную строку
	statusLine := fmt.Sprintf("%s %d %s\r\n", httpVersion, statusCode, http.StatusText(statusCode))
	if _, err := w.writer.WriteString(statusLine); err != nil {
		return
	}

	// Записываем заголовки
	for key, values := range w.header {
		for _, value := range values {
			headerLine := fmt.Sprintf("%s: %s\r\n", key, value)
			if _, err := w.writer.WriteString(headerLine); err != nil {
				return
			}
		}
	}

	// Записываем пустую строку, разделяющую заголовки и тело
	if _, err := w.writer.WriteString("\r\n"); err != nil {
		return
	}

	// Флушим буфер после записи заголовков
	// Важно: Flush должен записать все буферизованные данные в кольцевой буфер
	if err := w.writer.Flush(); err != nil {
		return
	}
}

// Flush отправляет все буферизованные данные в соединение.
func (w *responseWriter) Flush() {

	// Важно: Flush должен записать все буферизованные данные в кольцевой буфер
	// bufio.Writer.Flush() вызывает conn.Write() для всех буферизованных данных
	// Ошибка при flush игнорируется, так как это может быть временная ошибка
	// и данные могут быть записаны позже
	_ = w.writer.Flush()
}

var _ http.ResponseWriter = (*responseWriter)(nil)
