//go:build wasip1

// GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.

package wasm

import (
	"encoding/binary"
	"fmt"
	"io"
	"time"

	"github.com/goccy/go-json"

	"tgp/core/i18n"
)

// hostExecuteCommand вызывает host_execute_command из модуля command.
//
//go:wasmimport command host_execute_command
func hostExecuteCommand(commandPtr uint32, commandLen uint32, argsPtr uint32, argsLen uint32, workDirPtr uint32, workDirLen uint32, resultPtrPtr uint32, resultSizePtr uint32) (resultCode uint32)

// hostGetStreamReadBufferPtr получает указатель на кольцевой буфер для чтения из потока.
//
//go:wasmimport command host_get_stream_read_buffer_ptr
func hostGetStreamReadBufferPtr(streamID uint32, bufferPtrPtr uint32) (resultCode uint32)

// hostGetCommandResponse получает обновленный CommandResponse по stdoutStreamID.
//
//go:wasmimport command host_get_command_response
func hostGetCommandResponse(streamID uint32, resultPtrPtr uint32, resultSizePtr uint32) (resultCode uint32)

// ExecuteCommandInDir выполняет команду через хост в указанной директории.
// command - имя команды (например, "echo")
// args - аргументы команды
// workDir - рабочая директория (относительно rootDir)
// Возвращает результат выполнения команды или ошибку.
func ExecuteCommandInDir(command string, args []string, workDir string) (response *CommandResponse, err error) {

	// Кодируем args в JSON
	argsJSONBytes, err := json.Marshal(args)
	if err != nil {
		return nil, fmt.Errorf(i18n.Msg("failed to encode args")+": %w", err)
	}

	// Выделяем память для строк
	commandPtr, commandLen := StringToPtr(command)
	defer Free(commandPtr)

	argsPtr, argsLen := StringToPtr(string(argsJSONBytes))
	defer Free(argsPtr)

	workDirPtr, workDirLen := StringToPtr(workDir)
	defer Free(workDirPtr)

	// Выделяем память для указателей результата
	resultPtrPtr := Malloc(4)
	resultSizePtr := Malloc(4)
	defer Free(resultPtrPtr)
	defer Free(resultSizePtr)

	// Вызываем функцию хоста
	if hostExecuteCommand(commandPtr, commandLen, argsPtr, argsLen, workDirPtr, workDirLen, resultPtrPtr, resultSizePtr) != 0 {
		return nil, fmt.Errorf(i18n.Msg("failed to execute command"))
	}

	// Читаем указатель и размер результата
	resultPtr := binary.LittleEndian.Uint32(PtrToByte(resultPtrPtr, 4))
	resultSize := binary.LittleEndian.Uint32(PtrToByte(resultSizePtr, 4))

	if resultSize == 0 {
		return nil, fmt.Errorf(i18n.Msg("empty response from host"))
	}

	// Читаем результат
	resultBytes := PtrToByte(resultPtr, resultSize)
	defer Free(resultPtr)

	// Декодируем JSON напрямую в CommandResponse
	response = &CommandResponse{}
	if err := json.Unmarshal(resultBytes, response); err != nil {
		return nil, fmt.Errorf(i18n.Msg("failed to decode response")+": %w", err)
	}

	// Проверяем валидность streamID (должны быть > 0)
	if response.StdoutStreamID < 0 {
		return nil, fmt.Errorf(i18n.Msg("invalid stdout stream ID: negative value %d"), response.StdoutStreamID)
	}

	if response.StderrStreamID < 0 {
		return nil, fmt.Errorf(i18n.Msg("invalid stderr stream ID: negative value %d"), response.StderrStreamID)
	}

	return response, nil
}

// StreamReader реализует io.ReadCloser для чтения данных из потока через кольцевой буфер.
type StreamReader struct {
	streamID          uint32
	bufferDataSize    uint32 // Кэшированный размер области данных (константа)
	bufferDataSizeSet bool
}

// NewStreamReader создает новый StreamReader для чтения из потока.
func NewStreamReader(streamID uint32) (reader *StreamReader) {

	return &StreamReader{
		streamID: streamID,
	}
}

// Read читает данные из потока через кольцевой буфер.
// Блокирует до появления данных или до закрытия потока.
func (r *StreamReader) Read(p []byte) (n int, err error) {

	if len(p) == 0 {
		return 0, nil
	}

	// Получаем bufferPtr из streamID
	bufferPtr, err := getStreamReadBufferPtr(r.streamID)
	if err != nil {
		return 0, fmt.Errorf(i18n.Msg("failed to get buffer ptr")+": %w", err)
	}

	// Кэшируем DataSize при первом использовании
	if !r.bufferDataSizeSet {
		var header RingBufferHeader
		if header, err = ReadRingBufferHeader(bufferPtr); err != nil {
			return 0, fmt.Errorf(i18n.Msg("failed to read header for data size")+": %w", err)
		}
		r.bufferDataSize = header.DataSize
		r.bufferDataSizeSet = true
	}

	// Блокируем чтение до появления данных или до закрытия потока
	n, err = AdaptivePollingRead(func() (ready bool, n int, err error) {
		// Пытаемся прочитать данные из кольцевого буфера
		nRead, readErr := ReadFromRingBuffer(bufferPtr, r.bufferDataSize, p)
		if readErr != nil {
			return false, nRead, readErr
		}

		// Если что-то прочитано, возвращаем
		if nRead > 0 {
			return true, nRead, nil
		}

		// Буфер пуст, проверяем, закрыт ли поток
		// Читаем только флаг Closed (4 байта вместо всего заголовка)
		var closed uint32
		if closed, err = ReadClosedFlag(bufferPtr); err != nil {
			return false, 0, fmt.Errorf(i18n.Msg("failed to read closed flag")+": %w", err)
		}

		if closed != 0 {
			return false, 0, io.EOF
		}

		// Буфер пуст и поток не закрыт, продолжаем polling
		return false, 0, nil
	}, time.Time{})

	return n, err
}

// getStreamReadBufferPtr получает указатель на кольцевой буфер для чтения из потока.
func getStreamReadBufferPtr(streamID uint32) (bufferPtr uint32, err error) {

	// Выделяем память для bufferPtr (4 байта для uint32)
	bufferPtrPtr := Malloc(4)
	if bufferPtrPtr == 0 {
		return 0, fmt.Errorf(i18n.Msg("failed to allocate memory for bufferPtr"))
	}
	defer Free(bufferPtrPtr)

	// Вызываем host функцию
	// Может потребоваться несколько попыток, если поток еще не полностью создан
	maxRetries := 10
	for i := 0; i < maxRetries; i++ {
		if hostGetStreamReadBufferPtr(streamID, bufferPtrPtr) == 0 {
			// Читаем bufferPtr из памяти (little-endian uint32)
			bufferPtrData := PtrToByte(bufferPtrPtr, 4)
			if len(bufferPtrData) < 4 {
				return 0, fmt.Errorf(i18n.Msg("invalid bufferPtr data size"))
			}

			bufferPtr = binary.LittleEndian.Uint32(bufferPtrData)
			if bufferPtr != 0 {
				return bufferPtr, nil
			}
		}

		// Если не получилось, делаем небольшую паузу и повторяем
		// Это позволяет хосту завершить создание потока
		if i < maxRetries-1 {
			time.Sleep(time.Millisecond * 5)
		}
	}

	return 0, fmt.Errorf(i18n.Msg("failed to get stream read buffer ptr after %d retries"), maxRetries)
}

// Close закрывает поток.
func (r *StreamReader) Close() (err error) {

	// Закрываем поток через хост (если нужно)
	// Пока просто возвращаем nil, так как хост сам закроет поток при завершении команды
	return nil
}

// GetCommandResponse получает обновленный CommandResponse по stdoutStreamID.
// streamID - ID потока stdout команды
// Возвращает обновленный CommandResponse с реальным exitCode.
func GetCommandResponse(streamID uint32) (response *CommandResponse, err error) {

	// Выделяем память для указателей результата
	resultPtrPtr := Malloc(4)
	resultSizePtr := Malloc(4)
	defer Free(resultPtrPtr)
	defer Free(resultSizePtr)

	// Вызываем host функцию
	if hostGetCommandResponse(streamID, resultPtrPtr, resultSizePtr) != 0 {
		return nil, fmt.Errorf(i18n.Msg("failed to get command response"))
	}

	// Читаем указатель и размер результата
	resultPtr := binary.LittleEndian.Uint32(PtrToByte(resultPtrPtr, 4))
	resultSize := binary.LittleEndian.Uint32(PtrToByte(resultSizePtr, 4))

	if resultSize == 0 {
		return nil, fmt.Errorf(i18n.Msg("empty response from host"))
	}

	// Читаем результат
	resultBytes := PtrToByte(resultPtr, resultSize)
	defer Free(resultPtr)

	// Декодируем JSON напрямую в CommandResponse
	response = &CommandResponse{}
	if err := json.Unmarshal(resultBytes, response); err != nil {
		return nil, fmt.Errorf(i18n.Msg("failed to decode response")+": %w", err)
	}

	return response, nil
}
