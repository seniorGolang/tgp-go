// Copyright (c) 2026 Khramtsov Aleksei (seniorGolang@gmail.com).
// conditions defined in file 'LICENSE', which is part of this project source code.
package renderer

import (
	"path"
	"slices"
	"strings"

	"tgp/internal/model"
	"tgp/plugins/client-ts/tsg"
)

func (r *ClientRenderer) RenderClient() error {

	outDir := r.outDir
	file := tsg.NewFile()
	file.Comment("// GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.\n")

	// Импорты
	file.ImportType("./options", "ClientOptions")
	if r.HasJsonRPC() {
		file.ImportNamed("./jsonrpc/client", "JsonRpcClient")
		file.ImportType("./batch", "BatchRequest", "RpcCallback")
		file.ImportType("./jsonrpc/utils/jsonrpc", "RequestRPC", "ResponseRPC", "ID")
	}

	// Импорты клиентов контрактов
	contracts := make([]*model.Contract, len(r.project.Contracts))
	copy(contracts, r.project.Contracts)
	slices.SortFunc(contracts, func(a, b *model.Contract) int {
		if a.Name < b.Name {
			return -1
		}
		if a.Name > b.Name {
			return 1
		}
		return 0
	})
	for _, contract := range contracts {
		if model.IsAnnotationSet(r.project, contract, nil, nil, model.TagServerJsonRPC) {
			clientClassName := contract.Name + "Client"
			file.ImportNamed("./"+r.tsFileName(contract), clientClassName)
		}
		if model.IsAnnotationSet(r.project, contract, nil, nil, model.TagServerHTTP) {
			httpClientClassName := contract.Name + "HTTPClient"
			file.ImportNamed("./"+r.tsFileName(contract)+"-http", httpClientClassName)
		}
	}

	file.GenerateImports()
	file.Line()

	file.Add(r.renderBaseClientClass())
	file.Line()

	file.Add(r.renderNewClientFunction())
	file.Line()

	return file.Save(path.Join(outDir, "client.ts"))
}

func (r *ClientRenderer) renderBaseClientClass() *tsg.Statement {
	stmt := tsg.NewStatement()
	stmt.Comment("Base client for all services")
	stmt.Export().Class("Client", func(grp *tsg.Group) {
		// Приватные поля
		if r.HasJsonRPC() {
			grp.Add(tsg.NewStatement().Private().Id("rpcClient").Colon().Id("JsonRpcClient").Semicolon())
		}
		grp.Add(tsg.NewStatement().Private().Id("endpoint").Colon().Id("string").Semicolon())
		grp.Add(tsg.NewStatement().Private().Id("options").Colon().Id("ClientOptions").Semicolon())
		grp.Line()

		// Конструктор
		constructor := tsg.NewStatement()
		constructor.Id("constructor")
		constructor.Params(func(cg *tsg.Group) {
			cg.Add(tsg.NewStatement().Id("endpoint").Colon().Id("string"))
			cg.Add(tsg.NewStatement().Id("opts").Optional().Colon().Id("Partial").Generic("ClientOptions"))
		})
		constructor.BlockFunc(func(cg *tsg.Group) {
			// Сохраняем endpoint
			cg.Add(tsg.NewStatement().This().Dot("endpoint").Op("=").Id("endpoint").Semicolon())

			// Объединяем опции
			cg.Add(tsg.NewStatement().Const("defaultOptions").Colon().Id("ClientOptions").Op("=").Values(func(og *tsg.Group) {
				og.Add(tsg.NewStatement().Id("url").Colon().Id("endpoint"))
				defaultFn := tsg.NewStatement()
				defaultFn.ArrowFunc().BlockFunc(func(bg *tsg.Group) {
					bg.Return(tsg.NewStatement().Id("crypto").Dot("randomUUID").Call())
				})
				og.Add(tsg.NewStatement().Id("idGeneratorFn").Colon().Add(defaultFn))
			}).Semicolon())

			cg.Add(tsg.NewStatement().This().Dot("options").Op("=").Id("Object").Dot("assign").Call(
				tsg.NewStatement().Values(func(vg *tsg.Group) {}),
				tsg.NewStatement().Id("defaultOptions"),
				tsg.NewStatement().Id("opts").Op("||").Values(func(vg *tsg.Group) {}),
			).Semicolon())

			// Создаем JSON-RPC клиент
			if r.HasJsonRPC() {
				cg.Add(tsg.NewStatement().This().Dot("rpcClient").Op("=").New("JsonRpcClient").Call(
					tsg.NewStatement().This().Dot("options"),
				).Semicolon())
			}
		})
		grp.Add(constructor)
		grp.Line()

		// Публичные геттеры для доступа к внутренним ресурсам
		if r.HasJsonRPC() {
			grp.Add(tsg.NewStatement().Id("getRpcClient").Call().Colon().Id("JsonRpcClient").BlockFunc(func(mg *tsg.Group) {
				mg.Return(tsg.NewStatement().This().Dot("rpcClient"))
			}))
			grp.Line()
		}

		grp.Add(tsg.NewStatement().Id("getEndpoint").Call().Colon().Id("string").BlockFunc(func(mg *tsg.Group) {
			mg.Return(tsg.NewStatement().This().Dot("endpoint"))
		}))
		grp.Line()

		// Вспомогательный метод для получения заголовков (поддерживает статичные и динамические)
		grp.Add(tsg.NewStatement().
			Comment("Gets headers for the request, supporting both static headers and dynamic header functions").
			AsyncMethodWithParams("getHeaders", nil, tsg.NewStatement().Id("Record").Generic("string", "string"), func(mg *tsg.Group) {
				mg.If(
					tsg.NewStatement().Id("this").Dot("options").Dot("headers").Op("&&").Id("typeof").Call(tsg.NewStatement().Id("this").Dot("options").Dot("headers")).Op("===").Lit("function"),
					func(ig *tsg.Group) {
						// Если это функция, вызываем её (async функция автоматически обернет Promise)
						ig.Return(tsg.NewStatement().Id("this").Dot("options").Dot("headers").Call())
					},
				)
				// Иначе возвращаем статичные заголовки или пустой объект
				mg.If(
					tsg.NewStatement().Id("this").Dot("options").Dot("headers").Op("&&").Id("typeof").Call(tsg.NewStatement().Id("this").Dot("options").Dot("headers")).Op("!==").Lit("function"),
					func(ig *tsg.Group) {
						ig.Return(tsg.NewStatement().Id("this").Dot("options").Dot("headers").Op("as").Id("Record").Generic("string", "string"))
					},
				)
				// Если ничего не подошло, возвращаем пустой объект
				mg.Return(tsg.NewStatement().ObjectLiteral(nil))
			}))
		grp.Line()

		// Метод Batch для выполнения batch запросов
		if r.HasJsonRPC() {
			grp.Add(r.renderBatchMethod())
			grp.Line()
		}

		contracts := make([]*model.Contract, len(r.project.Contracts))
		copy(contracts, r.project.Contracts)
		slices.SortFunc(contracts, func(a, b *model.Contract) int {
			if a.Name < b.Name {
				return -1
			}
			if a.Name > b.Name {
				return 1
			}
			return 0
		})
		for _, contract := range contracts {
			if model.IsAnnotationSet(r.project, contract, nil, nil, model.TagServerJsonRPC) || model.IsAnnotationSet(r.project, contract, nil, nil, model.TagServerHTTP) {
				grp.Add(r.renderContractClientMethod(contract))
				grp.Line()
			}
		}
	})
	return stmt
}

func (r *ClientRenderer) renderNewClientFunction() *tsg.Statement {
	stmt := tsg.NewStatement()
	stmt.Comment("Creates a new base client")
	stmt.Comment("@param endpoint - Server endpoint URL")
	stmt.Comment("@param opts - Optional client configuration")
	stmt.Export().Func("newClient")
	stmt.Params(func(pg *tsg.Group) {
		pg.Add(tsg.NewStatement().Id("endpoint").Colon().Id("string"))
		pg.Add(tsg.NewStatement().Id("opts").Optional().Colon().Id("Partial").Generic("ClientOptions"))
	})
	stmt.Colon()
	stmt.Id("Client")
	stmt.BlockFunc(func(bg *tsg.Group) {
		bg.Return(tsg.NewStatement().New("Client").Call(
			tsg.NewStatement().Id("endpoint"),
			tsg.NewStatement().Id("opts"),
		))
	})
	return stmt
}

func (r *ClientRenderer) renderContractClientMethod(contract *model.Contract) *tsg.Statement {
	stmt := tsg.NewStatement()
	fileName := r.tsFileName(contract)
	// Например: "http_service" -> "httpService", "json_rpc_service" -> "jsonRpcService"
	methodName := ""
	parts := strings.Split(fileName, "_")
	for i, part := range parts {
		if i == 0 {
			methodName += part
		} else if len(part) > 0 {
			methodName += strings.ToUpper(string(part[0])) + part[1:]
		}
	}
	clientClassName := contract.Name + "Client"

	// Для JSON-RPC контрактов
	if model.IsAnnotationSet(r.project, contract, nil, nil, model.TagServerJsonRPC) {
		stmt.Id(methodName)
		stmt.Params(func(pg *tsg.Group) {
			// Пустые параметры
		})
		stmt.Colon()
		stmt.Id(clientClassName)
		stmt.BlockFunc(func(bg *tsg.Group) {
			bg.Return(tsg.NewStatement().New(clientClassName).Call(tsg.NewStatement().This()))
		})
	}

	if model.IsAnnotationSet(r.project, contract, nil, nil, model.TagServerHTTP) {
		httpMethodName := methodName + "HTTP"
		httpClientClassName := contract.Name + "HTTPClient"
		stmt.Line()
		stmt.Id(httpMethodName)
		stmt.Params(func(pg *tsg.Group) {
			// Пустые параметры
		})
		stmt.Colon()
		stmt.Id(httpClientClassName)
		stmt.BlockFunc(func(bg *tsg.Group) {
			bg.Return(tsg.NewStatement().New(httpClientClassName).Call(tsg.NewStatement().This()))
		})
	}

	return stmt
}

func (r *ClientRenderer) renderBatchMethod() *tsg.Statement {
	stmt := tsg.NewStatement()
	stmt.Comment("Executes a batch of JSON-RPC requests")
	methodParams := tsg.NewStatement()
	methodParams.Params(func(pg *tsg.Group) {
		// Параметр: requests: BatchRequest[]
		pg.Add(tsg.NewStatement().Id("requests").Colon().Id("BatchRequest").Array(nil))
	})
	returnType := tsg.NewStatement()
	returnType.Void()
	stmt.AsyncMethodWithParams("batch", methodParams, returnType, func(bg *tsg.Group) {
		bg.Add(tsg.NewStatement().Const("rpcRequests").Colon().Id("RequestRPC").Array(nil).Op("=").Index(nil).Semicolon())
		bg.Add(tsg.NewStatement().Const("callbacks").Colon().Id("Map").Generic("ID", "RpcCallback").Op("=").New("Map").Call().Semicolon())
		bg.Add(tsg.NewStatement().ForOf("request", "requests", func(fbg *tsg.Group) {
			fbg.Add(tsg.NewStatement().Id("rpcRequests").Dot("push").Call(tsg.NewStatement().Id("request").Dot("rpcRequest")).Semicolon())
			fbg.If(
				tsg.NewStatement().Id("request").Dot("retHandler").Op("!==").Id("undefined"),
				func(ig *tsg.Group) {
					ig.Add(tsg.NewStatement().Id("callbacks").Dot("set").Call(
						tsg.NewStatement().Id("request").Dot("rpcRequest").Dot("id"),
						tsg.NewStatement().Id("request").Dot("retHandler"),
					).Semicolon())
				},
			)
		}))

		// Вызываем callBatch
		responseType := tsg.NewStatement()
		responseType.Nullable(tsg.NewStatement().Id("Map").Generic("ID", "ResponseRPC"))
		bg.Add(tsg.NewStatement().Const("rpcResponses").Colon().Add(responseType).Op("=").Await(
			tsg.NewStatement().This().Dot("rpcClient").Dot("callBatch").Call(tsg.NewStatement().Id("rpcRequests")),
		).Semicolon())

		// Обработка ошибки или null
		bg.If(
			tsg.NewStatement().Id("rpcResponses").Op("===").Id("null"),
			func(ig *tsg.Group) {
				ig.Add(tsg.NewStatement().ForOf("callback", "callbacks.values()", func(fbg *tsg.Group) {
					fbg.Add(tsg.NewStatement().Id("callback").Call(
						tsg.NewStatement().New("Error").Call(tsg.NewStatement().Lit("batch request failed")),
						tsg.NewStatement().Id("null"),
					).Semicolon())
				}))
				ig.Return()
			},
		)

		forLoopStmt := tsg.NewStatement()
		forLoopStmt.ForOf("[id, response]", "rpcResponses", func(fbg *tsg.Group) {
			fbg.Add(tsg.NewStatement().Const("callback").Colon().Id("RpcCallback").Op("|").Id("undefined").Op("=").Id("callbacks").Dot("get").Call(tsg.NewStatement().Id("id")).Semicolon())
			fbg.If(
				tsg.NewStatement().Id("callback"),
				func(cig *tsg.Group) {
					cig.If(
						tsg.NewStatement().Id("response").Op("!=").Id("null").Op("&&").Id("response").Dot("error"),
						func(eg *tsg.Group) {
							errorMsg := tsg.NewStatement()
							errorMsg.Const("errorMsg").Colon().Id("string").Op("=")
							errorMsg.Id("response.error").Op("&&").Id("typeof").Call(tsg.NewStatement().Id("response.error")).Op("===").Lit("object").Op("&&").Id("response.error.message")
							errorMsg.Op("||").Lit("unknown error")
							eg.Add(errorMsg.Semicolon())
							eg.Add(tsg.NewStatement().Id("callback").Call(
								tsg.NewStatement().New("Error").Call(tsg.NewStatement().Id("errorMsg")),
								tsg.NewStatement().Id("response"),
							).Semicolon())
						},
					)
					cig.If(
						tsg.NewStatement().Id("response").Op("!=").Id("null").Op("&&").Op("!").Id("response").Dot("error"),
						func(eg *tsg.Group) {
							eg.Add(tsg.NewStatement().Id("callback").Call(
								tsg.NewStatement().Id("null"),
								tsg.NewStatement().Id("response"),
							).Semicolon())
						},
					)
				},
			)
		})
		bg.Add(forLoopStmt)
	})
	return stmt
}
