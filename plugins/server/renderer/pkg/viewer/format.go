// GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.

package viewer

import (
	"bytes"
	"encoding/json"
	"fmt"
	"reflect"
	"strconv"
)

const (
	supportedFlags = "0-+# "
)

var (
	percentBytes   = []byte("%")
	precisionBytes = []byte(".")
)

type formatState struct {
	value    any
	fs       fmt.State
	cs       *ConfigState
	pointers map[uintptr]int
}

func (f *formatState) Format(fs fmt.State, verb rune) {

	f.fs = fs
	if verb != 'v' {
		format := f.constructOrigFormat(verb)
		_, _ = fmt.Fprintf(fs, format, f.value)
		return
	}
	if f.value == nil {
		_, _ = fs.Write([]byte("null"))
		return
	}
	tree, err := toJSONTree(reflect.ValueOf(f.value), 0, f.pointers, f.cs, nil)
	if err != nil {
		_, _ = fs.Write([]byte(jsonPlaceholderInvalid))
		return
	}
	var out []byte
	if f.cs.Indent != "" {
		out, err = json.MarshalIndent(tree, "", f.cs.Indent)
	} else {
		out, err = json.Marshal(tree)
	}
	if err != nil {
		_, _ = fs.Write([]byte(jsonPlaceholderInvalid))
		return
	}
	_, _ = fs.Write(out)
}

func (f *formatState) constructOrigFormat(verb rune) (format string) {

	buf := bytes.NewBuffer(percentBytes)
	for _, flag := range supportedFlags {
		if f.fs.Flag(int(flag)) {
			buf.WriteRune(flag)
		}
	}
	if width, ok := f.fs.Width(); ok {
		buf.WriteString(strconv.Itoa(width))
	}
	if precision, ok := f.fs.Precision(); ok {
		buf.Write(precisionBytes)
		buf.WriteString(strconv.Itoa(precision))
	}
	buf.WriteRune(verb)
	return buf.String()
}
