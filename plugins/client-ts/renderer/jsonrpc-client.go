// Copyright (c) 2026 Khramtsov Aleksei (seniorGolang@gmail.com).
// conditions defined in file 'LICENSE', which is part of this project source code.
package renderer

import (
	"fmt"
	"log/slog"
	"path"
	"strings"

	"tgp/plugins/client-ts/tsg"

	"tgp/core/i18n"
	"tgp/internal/common"
	"tgp/internal/model"
)

func (r *ClientRenderer) RenderJsonRPCClientClass(contract *model.Contract) (err error) {

	if contract == nil {
		slog.Error(i18n.Msg("RenderJsonRPCClientClass: contract is nil"))
		return fmt.Errorf("contract is nil")
	}
	if contract.PkgPath == "" {
		slog.Error(i18n.Msg("RenderJsonRPCClientClass: contract.PkgPath is empty"), slog.String("contract", contract.Name))
		return fmt.Errorf("contract.PkgPath is empty for contract %s", contract.Name)
	}

	outDir := r.outDir
	r.contract = contract
	r.knownTypes = make(map[string]int)
	r.typeDefTs = make(map[string]typeDefTs)

	file := tsg.NewFile()
	file.Comment("// GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.\n")

	file.ImportNamed("./client", "Client")
	file.ImportNamed("./jsonrpc/client", "JsonRpcClient")
	file.ImportNamed("./jsonrpc/utils/jsonrpc", "JsonRpcCall")
	file.ImportType("./jsonrpc/utils/jsonrpc", "JsonRpcParams", "ResponseRPC")
	file.ImportType("./jsonrpc/utils/ts", "MapBatchResult")
	file.ImportType("./batch", "BatchRequest")

	for _, method := range contract.Methods {
		args := r.argsWithoutContext(method)
		for _, arg := range args {
			_ = r.walkVariable(arg.Name, contract.PkgPath, arg, method.Annotations, true)
		}
		results := r.resultsWithoutError(method)
		for _, ret := range results {
			_ = r.walkVariable(ret.Name, contract.PkgPath, ret, method.Annotations, false)
		}
	}

	exchangePath := fmt.Sprintf("./%s-exchange", r.tsFileName(contract))
	exchangeTypes := make([]string, 0, len(contract.Methods)*2)
	seenTypes := make(map[string]bool)
	for _, method := range contract.Methods {
		if !r.methodIsJsonRPC(contract, method) {
			continue
		}
		args := r.argsWithoutContext(method)
		if len(args) > 0 {
			requestType := r.requestTypeName(contract, method)
			if !seenTypes[requestType] {
				exchangeTypes = append(exchangeTypes, requestType)
				seenTypes[requestType] = true
			}
		}
		results := r.resultsWithoutError(method)
		if len(results) > 0 {
			responseType := r.responseTypeName(contract, method)
			if !seenTypes[responseType] {
				exchangeTypes = append(exchangeTypes, responseType)
				seenTypes[responseType] = true
			}
		}
	}
	if len(exchangeTypes) > 0 {
		file.ImportType(exchangePath, exchangeTypes...)
	}
	hasDtoTypes := false
	for _, def := range common.SortedPairs(r.typeDefTs) {
		if def.importPkg == "dto" {
			hasDtoTypes = true
			break
		}
	}
	if hasDtoTypes {
		file.ImportAll(exchangePath, "dto")
	}

	file.GenerateImports()
	file.Line()

	importedTypes := make(map[string]bool)
	for _, typeName := range exchangeTypes {
		importedTypes[typeName] = true
	}
	for _, def := range common.SortedPairs(r.typeDefTs) {
		typeName := def.importName
		if typeName == "" {
			typeName = def.name
		}
		if importedTypes[typeName] {
			continue
		}
		if def.importPkg == "dto" {
			continue
		}
		file.Add(r.renderTypeDef(def))
		file.Line()
	}

	allErrorsMap := make(map[string]errorInfo)
	for _, method := range contract.Methods {
		methodErrors := r.collectMethodErrors(method, contract)
		for key, errInfo := range methodErrors {
			if _, exists := allErrorsMap[key]; !exists {
				allErrorsMap[key] = errInfo
			}
		}
	}

	for _, errInfo := range common.SortedPairs(allErrorsMap) {
		file.Add(r.renderErrorType(errInfo))
		file.Line()
	}

	for _, method := range contract.Methods {
		methodErrors := r.collectMethodErrors(method, contract)
		if len(methodErrors) > 0 {
			unionType := r.renderErrorUnionType(method.Name, methodErrors)
			if unionType != nil {
				file.Add(unionType)
				file.Line()
			}
		}
	}

	for _, method := range contract.Methods {
		if r.methodIsJsonRPC(contract, method) {
			results := r.resultsWithoutError(method)
			callbackTypeStmt := tsg.NewStatement()
			callbackTypeStmt.Export().Type("ret" + contract.Name + method.Name)
			callbackTypeStmt.Op("=")
			callbackFnType := tsg.NewStatement()
			callbackFnType.Params(func(fg *tsg.Group) {
				for _, ret := range results {
					typeStr := r.walkVariable(ret.Name, contract.PkgPath, ret, method.Annotations, false).typeLink()
					nullableType := tsg.NewStatement()
					nullableType.Add(tsg.TypeFromString(typeStr)).Op("|").Id("null")
					fg.Add(tsg.NewStatement().Id(ret.Name).Colon().Add(nullableType))
				}
				fg.Add(tsg.NewStatement().Id("error").Colon().Id("Error").Op("|").Id("null"))
			}).Op("=>").Id("void")
			callbackTypeStmt.Add(callbackFnType).Semicolon()
			file.Add(callbackTypeStmt)
			file.Line()
		}
	}

	clientClass := r.renderJsonRPCClientClass(contract)
	file.Add(clientClass)
	file.Line()

	outFilename := path.Join(outDir, fmt.Sprintf("%s.ts", r.tsFileName(contract)))
	return file.Save(outFilename)
}

func (r *ClientRenderer) renderJsonRPCClientClass(contract *model.Contract) *tsg.Statement {
	// Захват contract в замыкании: r.contract может меняться при обходе контрактов.
	currentContract := contract

	stmt := tsg.NewStatement()
	stmt.Comment(fmt.Sprintf("JSON-RPC client for %s service", contract.Name))
	filteredSvcDocs := r.filterDocsComments(contract.Docs)
	if len(filteredSvcDocs) > 0 {
		stmt.Comment(strings.Join(filteredSvcDocs, "\n"))
	}
	stmt.Export().Class(contract.Name+"Client", func(grp *tsg.Group) {
		grp.Add(tsg.NewStatement().Private().Id("baseClient").Colon().Id("Client").Semicolon())
		grp.Add(tsg.NewStatement().Private().Id("client").Colon().Id("JsonRpcClient").Semicolon())
		grp.Line()

		constructor := tsg.NewStatement()
		constructor.Comment(fmt.Sprintf("Creates a new JSON-RPC client for %s service", contract.Name))
		constructorStmt := tsg.NewStatement()
		constructorStmt.Id("constructor")
		constructorStmt.Params(func(cg *tsg.Group) {
			cg.Add(tsg.NewStatement().Id("_baseClient").Colon().Id("Client"))
		})
		constructorStmt.BlockFunc(func(cg *tsg.Group) {
			cg.Add(tsg.NewStatement().This().Dot("baseClient").Op("=").Id("_baseClient").Semicolon())
			cg.Add(tsg.NewStatement().This().Dot("client").Op("=").Id("_baseClient").Dot("getRpcClient").Call().Semicolon())
		})
		grp.Add(constructorStmt)
		grp.Line()

		if r.contract == nil {
			slog.Error(i18n.Msg("renderJsonRPCClientClass: r.contract is nil in closure"))
			return
		}

		for _, method := range currentContract.Methods {
			if r.methodIsJsonRPC(currentContract, method) {
				r.renderJsonRPCMethod(grp, currentContract, method)
				r.renderJsonRPCRequestMethod(grp, currentContract, method)
			}
		}

		r.renderJsonRPCBatchMethod(grp, contract)
	})
	stmt.Export()
	return stmt
}

func (r *ClientRenderer) renderJsonRPCMethod(grp *tsg.Group, contract *model.Contract, method *model.Method) {
	filteredDocs := r.filterDocsComments(method.Docs)
	if len(filteredDocs) > 0 {
		grp.Comment(strings.Join(filteredDocs, "\n"))
	} else {
		grp.Comment(fmt.Sprintf("Calls %s.%s method", contract.Name, method.Name))
	}

	args := r.argsWithoutContext(method)
	results := r.resultsWithoutError(method)

	methodParams := tsg.NewStatement()
	methodParams.Params(func(pg *tsg.Group) {
		if len(args) > 0 {
			for _, arg := range args {
				typeStr := r.walkVariable(arg.Name, contract.PkgPath, arg, method.Annotations, true).typeLink()
				paramStmt := tsg.NewStatement()
				paramStmt.Id(arg.Name)
				if model.IsAnnotationSet(r.project, contract, method, nil, "nullable") {
					paramStmt.Optional()
				}
				paramStmt.Colon()
				paramStmt.Add(tsg.TypeFromString(typeStr))
				pg.Add(paramStmt)
			}
		}
	})

	// Тип возвращаемого значения
	returnType := r.resultToTypeStatement(method, results)

	requestTypeName := r.requestTypeName(contract, method)
	responseTypeName := r.responseTypeName(contract, method)

	methodStmt := tsg.NewStatement()
	methodStmt.Public()
	methodStmt.AsyncMethodWithParams(r.lcName(method.Name), methodParams, returnType, func(mg *tsg.Group) {
		if len(args) > 0 {
			paramsObj := tsg.NewStatement()
			paramsObj.Const("params").Colon().Id(requestTypeName).Op("=")
			paramsObj.Values(func(vg *tsg.Group) {
				for _, arg := range args {
					vg.Add(tsg.NewStatement().Id(arg.Name).Colon().Id(arg.Name))
				}
			})
			mg.Add(paramsObj.Semicolon())
		} else {
			mg.Add(tsg.NewStatement().Const("params").Colon().Id("Record").Generic("string", "never").Op("=").Values(nil).Semicolon())
		}

		methodName := r.lcName(contract.Name) + "." + r.lcName(method.Name)
		execCall := tsg.NewStatement()
		execCall.This().Dot("client").Dot("exec")
		execCall.Call(
			tsg.NewStatement().Lit(methodName),
			tsg.NewStatement().Id("params"),
		)

		mg.Add(
			tsg.NewStatement().
				Const("execResult").
				Op("=").
				Await(execCall).
				Semicolon(),
		)

		methodErrors := r.collectMethodErrors(method, contract)
		if len(methodErrors) > 0 {
			mg.If(
				tsg.NewStatement().
					Id("execResult").
					Dot("type").
					Op("!==").
					Lit("success"),
				func(ig *tsg.Group) {
					unionTypeName := fmt.Sprintf("%sError", method.Name)
					errorVar := tsg.NewStatement()
					errorVar.Const("error").Colon().Id(unionTypeName).Op("=").Id("execResult").Dot("error").Op("as").Id(unionTypeName)
					ig.Add(errorVar.Semicolon())
					ig.Throw(tsg.NewStatement().Id("error"))
				},
			)
		} else {
			mg.If(
				tsg.NewStatement().
					Id("execResult").
					Dot("type").
					Op("!==").
					Lit("success"),
				func(ig *tsg.Group) {
					ig.Throw(tsg.NewStatement().Id("execResult").Dot("error"))
				},
			)
		}

		if len(results) == 0 {
			mg.Return()
		} else {
			mg.Add(tsg.NewStatement().Const("result").Colon().Id(responseTypeName).Op("=").Id("execResult").Dot("result").Op("as").Id(responseTypeName).Semicolon())

			if len(results) == 1 {
				if model.IsAnnotationSet(r.project, contract, method, nil, model.TagHttpEnableInlineSingle) {
					mg.Return(tsg.NewStatement().Id("result"))
				} else {
					// Один результат: возвращаем значение поля (как в Go), не обёртку.
					mg.Return(tsg.NewStatement().Id("result").Dot(tsSafeName(results[0].Name)))
				}
			} else {
				returnObj := tsg.NewStatement()
				returnObj.Values(func(rg *tsg.Group) {
					for _, ret := range results {
						rg.Add(tsg.NewStatement().Id(ret.Name).Colon().Id("result").Dot(ret.Name))
					}
				})
				mg.Return(returnObj)
			}
		}
	})
	grp.Add(methodStmt)
	grp.Line()
}

func (r *ClientRenderer) renderJsonRPCRequestMethod(grp *tsg.Group, contract *model.Contract, method *model.Method) {
	filteredDocs := r.filterDocsComments(method.Docs)
	if len(filteredDocs) > 0 {
		grp.Comment(strings.Join(filteredDocs, "\n"))
	} else {
		grp.Comment(fmt.Sprintf("Creates a RequestRPC for %s.%s method", contract.Name, method.Name))
	}

	args := r.argsWithoutContext(method)

	methodParams := tsg.NewStatement()
	methodParams.Params(func(pg *tsg.Group) {
		callbackTypeName := "ret" + contract.Name + method.Name
		pg.Add(tsg.NewStatement().Id("callback").Colon().Id(callbackTypeName))
		if len(args) > 0 {
			for _, arg := range args {
				typeStr := r.walkVariable(arg.Name, contract.PkgPath, arg, method.Annotations, true).typeLink()
				paramStmt := tsg.NewStatement()
				paramStmt.Id(arg.Name)
				if model.IsAnnotationSet(r.project, contract, method, nil, "nullable") {
					paramStmt.Optional()
				}
				paramStmt.Colon()
				paramStmt.Add(tsg.TypeFromString(typeStr))
				pg.Add(paramStmt)
			}
		}
	})

	returnType := tsg.NewStatement()
	returnType.Id("BatchRequest")

	requestTypeName := r.requestTypeName(contract, method)

	methodStmt := tsg.NewStatement()
	methodStmt.Id("req" + method.Name)
	if methodParams != nil {
		methodStmt.Add(methodParams)
	} else {
		methodStmt.Id("()")
	}
	if returnType != nil {
		methodStmt.Colon().Add(returnType)
	}
	methodStmt.BlockFunc(func(bg *tsg.Group) {
		if len(args) > 0 {
			paramsObj := tsg.NewStatement()
			paramsObj.Const("params").Colon().Id(requestTypeName).Op("=")
			paramsObj.Values(func(vg *tsg.Group) {
				for _, arg := range args {
					vg.Add(tsg.NewStatement().Id(arg.Name).Colon().Id(arg.Name))
				}
			})
			bg.Add(paramsObj.Semicolon())
		} else {
			bg.Add(tsg.NewStatement().Const("params").Colon().Id("Record").Generic("string", "never").Op("=").Values(nil).Semicolon())
		}

		requestStmt := tsg.NewStatement()
		requestStmt.Const("_request").Colon().Id("BatchRequest").Op("=")
		requestStmt.Values(func(vg *tsg.Group) {
			rpcRequestStmt := tsg.NewStatement()
			rpcRequestStmt.Id("rpcRequest").Colon()
			rpcRequestStmt.Values(func(rg *tsg.Group) {
				rg.Add(tsg.NewStatement().ObjectField("jsonrpc", tsg.NewStatement().Lit("2.0")))
				rg.Add(tsg.NewStatement().ObjectField("method", tsg.NewStatement().Lit(r.lcName(contract.Name)+"."+r.lcName(method.Name))))
				rg.Add(tsg.NewStatement().ObjectField("params", tsg.NewStatement().Id("params")))
				idGen := tsg.NewStatement()
				idGen.Id("id").Colon().Id("this.baseClient.getRpcClient").Call().Dot("generateId").Call()
				rg.Add(idGen)
			})
			vg.Add(rpcRequestStmt)
			vg.Add(tsg.NewStatement().ObjectField("retHandler", tsg.NewStatement().Id("undefined")))
		})
		bg.Add(requestStmt.Semicolon())

		bg.If(
			tsg.NewStatement().Id("callback"),
			func(ig *tsg.Group) {
				results := r.resultsWithoutError(method)
				responseTypeName := r.responseTypeName(contract, method)

				retHandlerStmt := tsg.NewStatement()
				retHandlerStmt.Id("_request.retHandler").Op("=")
				retHandlerFn := tsg.NewStatement()
				arrowParams := tsg.NewStatement()
				arrowParams.Params(func(fg *tsg.Group) {
					fg.Add(tsg.NewStatement().Id("error").Colon().Id("Error").Op("|").Id("null"))
					fg.Add(tsg.NewStatement().Id("rpcResponse").Colon().Id("ResponseRPC").Op("|").Id("null"))
				})
				retHandlerFn.Add(arrowParams).Op("=>")
				retHandlerFn.BlockFunc(func(hg *tsg.Group) {
					hg.If(
						tsg.NewStatement().Id("error").Op("===").Id("null").Op("&&").Id("rpcResponse"),
						func(ig *tsg.Group) {
							ig.If(
								tsg.NewStatement().Id("rpcResponse.error"),
								func(eg *tsg.Group) {
									errorMsgStmt := tsg.NewStatement()
									errorMsgStmt.Const("errorMsg").Colon().Id("string").Op("=")
									errorMsgStmt.Id("rpcResponse.error").Op("&&").Id("typeof").Call(tsg.NewStatement().Id("rpcResponse.error")).Op("===").Lit("object").Op("&&").Id("rpcResponse.error.message")
									errorMsgStmt.Op("||").Lit("unknown error")
									eg.Add(errorMsgStmt.Semicolon())

									callbackArgs := make([]*tsg.Statement, 0, len(results)+1)
									for range results {
										callbackArgs = append(callbackArgs, tsg.NewStatement().Id("null"))
									}
									callbackArgs = append(callbackArgs, tsg.NewStatement().New("Error").Call(tsg.NewStatement().Id("errorMsg")))
									eg.Add(tsg.NewStatement().Id("callback").Call(callbackArgs...).Semicolon())
								},
							)
							ig.If(
								tsg.NewStatement().Id("rpcResponse").Op("&&").Op("!").Id("rpcResponse.error"),
								func(sg *tsg.Group) {
									if len(results) == 0 {
										sg.Add(tsg.NewStatement().Id("callback").Call(
											tsg.NewStatement().Id("null"),
										).Semicolon())
									} else {
										sg.Add(tsg.NewStatement().Const("result").Colon().Id(responseTypeName).Op("=").Id("rpcResponse.result").Op("as").Id(responseTypeName).Semicolon())

										callbackArgs := []*tsg.Statement{}
										if len(results) == 1 {
											if model.IsAnnotationSet(r.project, contract, method, nil, model.TagHttpEnableInlineSingle) {
												callbackArgs = append(callbackArgs, tsg.NewStatement().Id("result"))
											} else {
												callbackArgs = append(callbackArgs, tsg.NewStatement().Id("result").Dot(tsSafeName(results[0].Name)))
											}
										} else {
											for _, ret := range results {
												callbackArgs = append(callbackArgs, tsg.NewStatement().Id("result").Dot(ret.Name))
											}
										}
										callbackArgs = append(callbackArgs, tsg.NewStatement().Id("null"))
										sg.Add(tsg.NewStatement().Id("callback").Call(callbackArgs...).Semicolon())
									}
								},
							)
						},
					)
					hg.If(
						tsg.NewStatement().Id("error").Op("||").Op("!").Id("rpcResponse"),
						func(eg *tsg.Group) {
							callbackArgs := make([]*tsg.Statement, 0, len(results)+1)
							for range results {
								callbackArgs = append(callbackArgs, tsg.NewStatement().Id("null"))
							}
							callbackArgs = append(callbackArgs, tsg.NewStatement().Id("error").Op("||").New("Error").Call(tsg.NewStatement().Lit("unknown error")))
							eg.Add(tsg.NewStatement().Id("callback").Call(callbackArgs...).Semicolon())
						},
					)
				})
				retHandlerStmt.Add(retHandlerFn).Semicolon()
				ig.Add(retHandlerStmt)
			},
		)

		bg.Return(tsg.NewStatement().Id("_request"))
	})
	grp.Add(methodStmt)
	grp.Line()
}

func (r *ClientRenderer) renderJsonRPCBatchMethod(grp *tsg.Group, contract *model.Contract) {
	grp.Comment("Executes a batch of JSON-RPC requests")
	grp.Comment("@param calls - Array of JSON-RPC calls to execute")

	genericParams := tsg.NewStatement()
	genericParams.Generic("Calls extends readonly JsonRpcCall<JsonRpcParams>[]")

	methodParams := tsg.NewStatement()
	methodParams.Params(func(pg *tsg.Group) {
		pg.Add(tsg.NewStatement().Id("calls").Colon().Id("Calls"))
	})

	returnType := tsg.NewStatement()
	returnType.Id("MapBatchResult").Generic("Calls")

	methodStmt := tsg.NewStatement()
	methodStmt.AsyncMethodWithGeneric("execBatch", genericParams, methodParams, returnType, func(mg *tsg.Group) {
		mg.Return(
			tsg.NewStatement().
				This().
				Dot("client").
				Dot("callBatch").
				Call(tsg.NewStatement().Id("calls")).
				Op("as").
				Id("MapBatchResult").
				Generic("Calls"),
		)
	})
	grp.Add(methodStmt)
	grp.Line()
}

func (r *ClientRenderer) resultToTypeStatement(method *model.Method, vars []*model.Variable) *tsg.Statement {

	if len(vars) == 0 {
		return tsg.NewStatement().Id("void")
	}

	// r.contract может быть nil при обходе контрактов; обращение к полям вызовет панику.
	if r.contract == nil {
		slog.Error(i18n.Msg("resultToTypeStatement: r.contract is nil"), slog.String("method", method.Name))
		return tsg.NewStatement().Id("any")
	}

	var pkgPath string
	if r.contract != nil {
		pkgPath = r.contract.PkgPath
		if pkgPath == "" {
			slog.Error(i18n.Msg("resultToTypeStatement: contract.PkgPath is empty"), slog.String("contract", r.contract.Name), slog.String("method", method.Name))
			return tsg.NewStatement().Id("any")
		}
	} else {
		slog.Error(i18n.Msg("resultToTypeStatement: r.contract is nil after check"), slog.String("method", method.Name))
		return tsg.NewStatement().Id("any")
	}

	if len(vars) == 1 {
		schema := r.walkVariable(vars[0].Name, pkgPath, vars[0], method.Annotations, false)
		typeStr := schema.typeLink()
		return tsg.TypeFromString(typeStr)
	}

	stmt := tsg.NewStatement()
	stmt.Values(func(grp *tsg.Group) {
		for _, ret := range vars {
			schema := r.walkVariable(ret.Name, pkgPath, ret, method.Annotations, false)
			typeStr := schema.typeLink()
			field := tsg.NewStatement()
			field.Id(ret.Name)
			if model.IsAnnotationSet(r.project, r.contract, method, nil, "nullable") {
				field.Optional()
			}
			field.Colon()
			field.Add(tsg.TypeFromString(typeStr))
			field.Semicolon()
			grp.Add(field)
		}
	})
	return stmt
}
