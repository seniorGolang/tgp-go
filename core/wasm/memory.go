//go:build wasip1

// GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.

package wasm

import (
	"errors"
	"fmt"
	"sync"
	"unsafe"

	"tgp/core/i18n"
)

// Управление памятью для WASM плагина.
// В WASM Go heap находится в линейной памяти, поэтому можно использовать unsafe.Pointer.
var allocations = make(map[uint32][]byte)
var allocationsMu sync.Mutex

func allocate(size uint32) (ptr uint32) {

	if size == 0 {
		return 0
	}
	// Выделяем память в Go heap (который находится в линейной памяти WASM)
	b := make([]byte, size)
	// В WASM Go heap находится в линейной памяти, поэтому unsafe.Pointer работает
	ptr = uint32(uintptr(unsafe.Pointer(&b[0])))
	// Сохраняем slice в map для предотвращения GC
	allocationsMu.Lock()
	allocations[ptr] = b
	allocationsMu.Unlock()
	return ptr
}

// Malloc выделяет память (используется в плагине через экспорт).
//
//go:wasmexport malloc
func Malloc(size uint32) (ptr uint32) {

	return allocate(size)
}

// Free освобождает память (используется в плагине через экспорт).
//
//go:wasmexport free
func Free(ptr uint32) {

	if ptr == 0 {
		return
	}

	allocationsMu.Lock()
	_, exists := allocations[ptr]
	if !exists {
		allocationsMu.Unlock()
		return
	}
	delete(allocations, ptr)
	allocationsMu.Unlock()
}

// PtrToByte преобразует указатель и размер в байтовый срез.
// В WASM Go heap находится в линейной памяти, поэтому unsafe.Pointer работает.
func PtrToByte(ptr, size uint32) (data []byte) {

	if ptr == 0 || size == 0 {
		return nil
	}
	//nolint:govet // unsafe.Pointer необходим для работы с WASM памятью
	return unsafe.Slice((*byte)(unsafe.Pointer(uintptr(ptr))), size)
}

// ByteToPtr записывает данные в WASM память по указанному адресу.
// Не выделяет память, только записывает данные.
func ByteToPtr(data []byte, ptr uint32) {

	if len(data) == 0 || ptr == 0 {
		return
	}

	// Записываем данные напрямую через unsafe.Pointer
	//nolint:govet // unsafe.Pointer необходим для работы с WASM памятью
	wasmPtr := unsafe.Pointer(uintptr(ptr))
	wasmMem := unsafe.Slice((*byte)(wasmPtr), len(data))
	copy(wasmMem, data)
}

// byteToPtr выделяет память через Malloc и записывает данные.
func byteToPtr(buf []byte) (ptr uint32, size uint32) {

	if len(buf) == 0 {
		return 0, 0
	}

	if len(buf) > int(^uint32(0)) {
		panic(fmt.Sprintf("buffer size too large for uint32: %d", len(buf)))
	}

	//nolint:gosec // Проверка на переполнение выполнена выше
	size = uint32(len(buf))
	ptr = Malloc(size)
	if ptr == 0 {
		panic("failed to allocate memory in WASM")
	}

	// Записываем данные напрямую через unsafe.Pointer
	wasmPtr := unsafe.Pointer(uintptr(ptr))
	wasmMem := unsafe.Slice((*byte)(wasmPtr), size)
	if len(wasmMem) < len(buf) {
		Free(ptr)
		panic("memory allocation size mismatch")
	}
	copy(wasmMem[:len(buf)], buf)

	return ptr, size
}

// StringToPtr преобразует строку в указатель и длину.
func StringToPtr(s string) (ptr uint32, size uint32) {

	return byteToPtr([]byte(s))
}

// ptrToString преобразует указатель и длину в строку.
func ptrToString(ptr, size uint32) (str string) {

	if ptr == 0 || size == 0 {
		return ""
	}
	//nolint:govet // unsafe.Pointer необходим для работы с WASM памятью
	return unsafe.String((*byte)(unsafe.Pointer(uintptr(ptr))), int(size))
}

// bytesToPtr преобразует байтовый срез в указатель (без выделения памяти).
func bytesToPtr(bytes []byte) (ptr uint64) {

	if len(bytes) == 0 {
		return 0
	}
	//nolint:govet // unsafe.Pointer необходим для работы с WASM памятью
	return uint64(uintptr(unsafe.Pointer(&bytes[0])))
}

// retUint64ToError преобразует возвращаемое значение uint64 в ошибку.
func retUint64ToError(u64 uint64) (err error) {

	if u64 == 0 {
		return nil
	}
	// Извлекаем ptr и length из uint64 (старшие 32 бита - ptr, младшие 32 бита - length)
	ptrValue := u64 >> 32
	if ptrValue > uint64(^uint32(0)) {
		return fmt.Errorf(i18n.Msg("pointer value too large: %d"), ptrValue)
	}
	//nolint:gosec // Проверка на переполнение выполнена выше
	ptr := uint32(ptrValue)
	//nolint:gosec // Маска 0xFFFFFFFF гарантирует, что значение помещается в uint32
	length := uint32(u64 & 0xFFFFFFFF)
	// Проверяем флаг ошибки (31-й бит в length)
	if length&(1<<31) != 0 {
		length ^= 1 << 31 // Убираем флаг ошибки
		errMsg := ptrToString(ptr, length)
		return errors.New(errMsg)
	}
	return nil
}
