//go:build wasip1

// GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.

package wasm

import (
	"context"
	"fmt"
	"unsafe"

	"tgp/core/i18n"
)

// CallHostReadWrite вызывает host функцию для чтения/записи данных.
// Функция fn должна принимать: connID uint64, bPtr, bLen, nPtr uint32
// и возвращать uint64 (0 при успехе, иначе ошибка).
// Результат (количество прочитанных/записанных байт) читается из nPtr.
func CallHostReadWrite(fn func(connID uint64, bPtr uint32, bLen uint32, nPtr uint32) uint64, connID uint64, buffer []byte) (n int, err error) {

	// Выделяем память для n (4 байта для uint32)
	nPtr := Malloc(4)
	if nPtr == 0 {
		return 0, fmt.Errorf(i18n.Msg("failed to allocate memory for n"))
	}
	defer Free(nPtr)

	// Получаем указатель на буфер
	bPtr := bytesToPtr(buffer)
	if bPtr > uint64(^uint32(0)) {
		return 0, fmt.Errorf(i18n.Msg("buffer pointer too large: %d"), bPtr)
	}

	bLen := len(buffer)
	if bLen > int(^uint32(0)) {
		return 0, fmt.Errorf(i18n.Msg("buffer length out of range: %d"), bLen)
	}

	bPtr32 := uint32(bPtr)
	bLen32 := uint32(bLen)

	// Вызываем host функцию
	ret := fn(connID, bPtr32, bLen32, nPtr)

	// Обрабатываем ошибку
	if err = HandleHostError(ret); err != nil {
		return 0, err
	}

	// Читаем n из памяти (little-endian uint32)
	//nolint:govet // unsafe.Pointer необходим для работы с WASM памятью
	nRead := *(*uint32)(unsafe.Pointer(uintptr(nPtr)))

	if nRead > ^uint32(0)>>1 {
		return 0, fmt.Errorf(i18n.Msg("read count too large: %d"), nRead)
	}

	return int(nRead), nil
}

// CallHostUint64 вызывает host функцию с одним uint64 параметром.
// Функция fn должна принимать: connID uint64 и возвращать uint64 (0 при успехе, иначе ошибка).
func CallHostUint64(fn func(connID uint64) uint64, connID uint64) (err error) {

	ret := fn(connID)
	return HandleHostError(ret)
}

// CallHostUint64WithDeadline вызывает host функцию с connID и deadline.
// Функция fn должна принимать: connID uint64, deadline uint64 и возвращать uint64 (0 при успехе, иначе ошибка).
func CallHostUint64WithDeadline(fn func(connID uint64, deadline uint64) uint64, connID uint64, deadline uint64) (err error) {

	ret := fn(connID, deadline)
	return HandleHostError(ret)
}

// readUint32FromPtrNoFree читает uint32 из памяти по указателю (little-endian) без освобождения памяти.
func readUint32FromPtrNoFree(ptr uint32) (value uint32, err error) {

	if ptr == 0 {
		return 0, fmt.Errorf(i18n.Msg("invalid pointer: 0"))
	}

	// Читаем 4 байта
	data := PtrToByte(ptr, 4)
	if len(data) < 4 {
		return 0, fmt.Errorf(i18n.Msg("invalid data size: expected 4, got %d"), len(data))
	}

	// Парсим uint32 (little-endian)
	value = uint32(data[0]) | uint32(data[1])<<8 | uint32(data[2])<<16 | uint32(data[3])<<24

	return value, nil
}

// CallHostDial вызывает host функцию для установки соединения.
// Функция fn должна принимать: networkPtr, networkLen, addressPtr, addressLen, connIDPtr uint32
// и возвращать uint64 (0 при успехе, иначе ошибка).
// connID читается из connIDPtr после успешного вызова.
func CallHostDial(fn func(networkPtr uint32, networkLen uint32, addressPtr uint32, addressLen uint32, connIDPtr uint32) uint64, network string, address string) (connID uint32, err error) {

	// Преобразуем строки в указатели
	networkPtr, networkLen := StringToPtr(network)
	defer Free(networkPtr)

	addressPtr, addressLen := StringToPtr(address)
	defer Free(addressPtr)

	// Выделяем память для connID (4 байта для uint32)
	connIDPtr := Malloc(4)
	if connIDPtr == 0 {
		return 0, fmt.Errorf(i18n.Msg("failed to allocate memory for connID"))
	}
	defer Free(connIDPtr)

	// Вызываем host функцию
	ret := fn(networkPtr, networkLen, addressPtr, addressLen, connIDPtr)

	// Обрабатываем ошибку
	if err = HandleHostError(ret); err != nil {
		return 0, err
	}

	// Читаем connID из памяти
	connID, err = readUint32FromPtrNoFree(connIDPtr)
	if err != nil {
		return 0, fmt.Errorf(i18n.Msg("failed to read connID")+": %w", err)
	}

	return connID, nil
}

// CallHostDialWithContext вызывает host функцию для установки соединения с deadline из context.
// Функция fn должна принимать: deadline uint64, networkPtr, networkLen, addressPtr, addressLen, connIDPtr uint32
// и возвращать uint64 (0 при успехе, иначе ошибка).
// connID читается из connIDPtr после успешного вызова.
func CallHostDialWithContext(ctx context.Context, fn func(deadline uint64, networkPtr uint32, networkLen uint32, addressPtr uint32, addressLen uint32, connIDPtr uint32) uint64, network string, address string) (connID uint32, err error) {

	// Извлекаем deadline из context (если есть)
	var deadline uint64
	if d, ok := ctx.Deadline(); ok {
		nanos := d.UnixNano()
		if nanos < 0 {
			deadline = 0
		} else {
			deadline = uint64(nanos)
		}
	}

	// Преобразуем строки в указатели
	networkPtr, networkLen := StringToPtr(network)
	defer Free(networkPtr)

	addressPtr, addressLen := StringToPtr(address)
	defer Free(addressPtr)

	// Выделяем память для connID (4 байта для uint32)
	connIDPtr := Malloc(4)
	if connIDPtr == 0 {
		return 0, fmt.Errorf(i18n.Msg("failed to allocate memory for connID"))
	}
	defer Free(connIDPtr)

	// Вызываем host функцию
	ret := fn(deadline, networkPtr, networkLen, addressPtr, addressLen, connIDPtr)

	// Обрабатываем ошибку
	if err = HandleHostError(ret); err != nil {
		return 0, err
	}

	// Читаем connID из памяти
	connID, err = readUint32FromPtrNoFree(connIDPtr)
	if err != nil {
		return 0, fmt.Errorf(i18n.Msg("failed to read connID")+": %w", err)
	}

	return connID, nil
}
