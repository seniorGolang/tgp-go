//go:build wasip1

// GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.
package net

import (
	"context"
	"encoding/binary"
	"fmt"
	"net"

	"github.com/goccy/go-json"

	"tgp/core/i18n"
	"tgp/core/wasm"
)

// Dial устанавливает соединение с удалённым адресом.
func Dial(network, address string) (conn net.Conn, err error) {

	connID, err := wasm.CallHostDial(conn_dial, network, address)
	if err != nil {
		return nil, err
	}

	return &Conn{id: uint64(connID), network: network}, nil
}

// DialContext устанавливает соединение с удалённым адресом с использованием контекста.
func DialContext(ctx context.Context, network, address string) (conn net.Conn, err error) {

	connID, err := wasm.CallHostDialWithContext(ctx, conn_dial_context, network, address)
	if err != nil {
		return nil, err
	}

	return &Conn{id: uint64(connID), network: network}, nil
}

// DialTLS устанавливает TLS соединение с удалённым адресом.
func DialTLS(network, address string) (conn net.Conn, err error) {

	connID, err := wasm.CallHostDial(conn_dial_tls, network, address)
	if err != nil {
		return nil, err
	}

	return &Conn{id: uint64(connID), network: network}, nil
}

// DialTLSContext устанавливает TLS соединение с удалённым адресом с использованием контекста.
func DialTLSContext(ctx context.Context, network, address string) (conn net.Conn, err error) {

	connID, err := wasm.CallHostDialWithContext(ctx, conn_dial_tls_context, network, address)
	if err != nil {
		return nil, err
	}

	return &Conn{id: uint64(connID), network: network}, nil
}

// TLSConfig представляет конфигурацию TLS для соединения.
type TLSConfig struct {
	MinVersion         string   `json:"min_version,omitempty"`          // "1.0", "1.1", "1.2", "1.3"
	MaxVersion         string   `json:"max_version,omitempty"`          // "1.0", "1.1", "1.2", "1.3"
	InsecureSkipVerify bool     `json:"insecure_skip_verify,omitempty"` // пропустить проверку сертификата
	ServerName         string   `json:"server_name,omitempty"`          // имя сервера для SNI
	CipherSuites       []string `json:"cipher_suites,omitempty"`        // список поддерживаемых cipher suites
}

// DialTLSWithConfig устанавливает TLS соединение с настраиваемой конфигурацией TLS.
func DialTLSWithConfig(network, address string, config TLSConfig) (conn net.Conn, err error) {

	// Кодируем config в JSON
	configJSONBytes, err := json.Marshal(config)
	if err != nil {
		return nil, fmt.Errorf(i18n.Msg("failed to encode TLS config")+": %w", err)
	}

	// Преобразуем строки в указатели
	networkPtr, networkLen := wasm.StringToPtr(network)
	defer wasm.Free(networkPtr)

	addressPtr, addressLen := wasm.StringToPtr(address)
	defer wasm.Free(addressPtr)

	configPtr, configLen := wasm.StringToPtr(string(configJSONBytes))
	defer wasm.Free(configPtr)

	// Выделяем память для connID (4 байта для uint32)
	connIDPtr := wasm.Malloc(4)
	if connIDPtr == 0 {
		return nil, fmt.Errorf(i18n.Msg("failed to allocate memory for connID"))
	}
	defer wasm.Free(connIDPtr)

	// Вызываем host функцию
	ret := conn_dial_tls_with_config(networkPtr, networkLen, addressPtr, addressLen, configPtr, configLen, connIDPtr)

	// Обрабатываем ошибку
	if err = wasm.HandleHostError(ret); err != nil {
		return nil, err
	}

	// Читаем connID из памяти
	connIDBytes := wasm.PtrToByte(connIDPtr, 4)
	if len(connIDBytes) < 4 {
		return nil, fmt.Errorf(i18n.Msg("invalid connID data size"))
	}
	connID := binary.LittleEndian.Uint32(connIDBytes)

	return &Conn{id: uint64(connID), network: network}, nil
}

// TLSHandshake выполняет TLS handshake для соединения.
func TLSHandshake(conn net.Conn) (err error) {

	wasmConn, ok := conn.(*Conn)
	if !ok {
		return fmt.Errorf(i18n.Msg("connection is not a WASM connection"))
	}

	// Вызываем host функцию
	ret := conn_tls_handshake(wasmConn.id)

	// Обрабатываем ошибку
	return wasm.HandleHostError(ret)
}
