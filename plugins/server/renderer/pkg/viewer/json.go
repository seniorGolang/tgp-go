// GENERATED BY 'T'ool 'G'ateway. DO NOT EDIT.

package viewer

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strconv"
	"time"
)

const (
	dumpMethod             = "Dump"
	jsonPlaceholderShown   = "<shown>"
	jsonPlaceholderMax     = "<max>"
	jsonPlaceholderInvalid = "<invalid>"
	sliceMaxLen            = 16
	sliceHeadTail          = 4
	ptrHexPrefix           = "0x"
)

func toJSONTree(v reflect.Value, depth int, pointers map[uintptr]int, cs *ConfigState, opt option) (node any, err error) {

	kind := v.Kind()
	if kind == reflect.Invalid {
		return jsonPlaceholderInvalid, nil
	}
	if kind == reflect.Ptr {
		return toJSONTreePtr(v, depth, pointers, cs, opt)
	}
	if kind == reflect.Interface {
		if v.IsNil() {
			return nil, nil
		}
		return toJSONTree(v.Elem(), depth, pointers, cs, opt)
	}
	if toString := v.MethodByName("String"); toString.IsValid() {
		if v.Kind() == reflect.Ptr && v.IsNil() {
			return nil, nil
		}
		results := toString.Call(nil)
		if len(results) == 1 {
			s := string(applyOptions([]byte(results[0].String()), opt))
			return s, nil
		}
	}
	if method := v.MethodByName(dumpMethod); method.IsValid() {
		results := method.Call(nil)
		if len(results) == 1 {
			return results[0].String(), nil
		}
	}
	switch kind {
	case reflect.Bool:
		return v.Bool(), nil
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return v.Int(), nil
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		return v.Uint(), nil
	case reflect.Float32, reflect.Float64:
		return v.Float(), nil
	case reflect.Complex64, reflect.Complex128:
		return fmt.Sprintf("(%g+%gi)", real(v.Complex()), imag(v.Complex())), nil
	case reflect.String:
		return string(applyOptions([]byte(v.String()), opt)), nil
	case reflect.Slice:
		return toJSONTreeSlice(v, depth, pointers, cs, opt)
	case reflect.Array:
		return toJSONTreeSlice(v, depth, pointers, cs, opt)
	case reflect.Map:
		return toJSONTreeMap(v, depth, pointers, cs, opt)
	case reflect.Struct:
		return toJSONTreeStruct(v, depth, pointers, cs, opt)
	case reflect.UnsafePointer, reflect.Chan, reflect.Func:
		return ptrHexString(v.Pointer()), nil
	default:
		if v.CanInterface() {
			return v.Interface(), nil
		}
		return jsonPlaceholderInvalid, nil
	}
}

func toJSONTreePtr(v reflect.Value, depth int, pointers map[uintptr]int, cs *ConfigState, opt option) (node any, err error) {

	if v.IsNil() {
		return nil, nil
	}
	for k, d := range pointers {
		if d >= depth {
			delete(pointers, k)
		}
	}
	ve := v
	for ve.Kind() == reflect.Ptr {
		if ve.IsNil() {
			return nil, nil
		}
		addr := ve.Pointer()
		if pd, ok := pointers[addr]; ok && pd < depth {
			return jsonPlaceholderShown, nil
		}
		ve = ve.Elem()
		pointers[addr] = depth
		if ve.Kind() == reflect.Interface {
			if ve.IsNil() {
				return nil, nil
			}
			ve = ve.Elem()
		}
	}
	return toJSONTree(ve, depth, pointers, cs, opt)
}

func unpackValue(v reflect.Value) reflect.Value {

	for v.Kind() == reflect.Interface || v.Kind() == reflect.Ptr {
		if v.IsNil() {
			return v
		}
		v = v.Elem()
	}
	return v
}

func toJSONTreeSlice(v reflect.Value, depth int, pointers map[uintptr]int, cs *ConfigState, opt option) (node any, err error) {

	if v.Kind() == reflect.Slice && v.IsNil() {
		return nil, nil
	}
	childDepth := depth + 1
	if cs.MaxDepth != 0 && childDepth > cs.MaxDepth {
		return jsonPlaceholderMax, nil
	}
	n := v.Len()
	if n > sliceMaxLen {
		arr := make([]any, 0, 2*sliceHeadTail+1)
		for i := 0; i < sliceHeadTail; i++ {
			item, itemErr := toJSONTree(unpackValue(v.Index(i)), childDepth, pointers, cs, opt)
			if itemErr != nil {
				return nil, itemErr
			}
			arr = append(arr, item)
		}
		arr = append(arr, fmt.Sprintf(" <-[%d]->", n))
		for i := n - sliceHeadTail; i < n; i++ {
			item, itemErr := toJSONTree(unpackValue(v.Index(i)), childDepth, pointers, cs, opt)
			if itemErr != nil {
				return nil, itemErr
			}
			arr = append(arr, item)
		}
		return arr, nil
	}
	arr := make([]any, 0, n)
	for i := 0; i < n; i++ {
		item, itemErr := toJSONTree(unpackValue(v.Index(i)), childDepth, pointers, cs, opt)
		if itemErr != nil {
			return nil, itemErr
		}
		arr = append(arr, item)
	}
	return arr, nil
}

func toJSONTreeMap(v reflect.Value, depth int, pointers map[uintptr]int, cs *ConfigState, opt option) (node any, err error) {

	if v.IsNil() {
		return nil, nil
	}
	childDepth := depth + 1
	if cs.MaxDepth != 0 && childDepth > cs.MaxDepth {
		return jsonPlaceholderMax, nil
	}
	m := make(map[string]any)
	keys := v.MapKeys()
	for _, key := range keys {
		keyStr, keyErr := mapKeyString(key, childDepth, pointers, cs, opt)
		if keyErr != nil {
			return nil, keyErr
		}
		val, valErr := toJSONTree(unpackValue(v.MapIndex(key)), childDepth, pointers, cs, opt)
		if valErr != nil {
			return nil, valErr
		}
		m[keyStr] = val
	}
	return m, nil
}

func mapKeyString(v reflect.Value, depth int, pointers map[uintptr]int, cs *ConfigState, opt option) (keyStr string, err error) {

	switch v.Kind() {
	case reflect.String:
		return string(applyOptions([]byte(v.String()), opt)), nil
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return strconv.FormatInt(v.Int(), 10), nil
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		return strconv.FormatUint(v.Uint(), 10), nil
	case reflect.Bool:
		return strconv.FormatBool(v.Bool()), nil
	default:
		node, nodeErr := toJSONTree(v, depth, pointers, cs, opt)
		if nodeErr != nil {
			return "", nodeErr
		}
		b, marshalErr := json.Marshal(node)
		if marshalErr != nil {
			return "", marshalErr
		}
		return string(b), nil
	}
}

func toJSONTreeStruct(v reflect.Value, depth int, pointers map[uintptr]int, cs *ConfigState, opt option) (node any, err error) {

	if v.Type() == reflect.TypeOf(time.Time{}) {
		return v.Interface().(time.Time).Format(time.RFC3339), nil
	}
	childDepth := depth + 1
	if cs.MaxDepth != 0 && childDepth > cs.MaxDepth {
		return jsonPlaceholderMax, nil
	}
	m := make(map[string]any)
	vt := v.Type()
	for i := 0; i < v.NumField(); i++ {
		fieldOpt := tagToOption(vt.Field(i).Tag.Get(tagName))
		fieldVal, fieldErr := toJSONTree(unpackValue(v.Field(i)), childDepth, pointers, cs, fieldOpt)
		if fieldErr != nil {
			return nil, fieldErr
		}
		m[vt.Field(i).Name] = fieldVal
	}
	return m, nil
}

func ptrHexString(p uintptr) string {
	if p == 0 {
		return ptrHexPrefix + "0"
	}
	return ptrHexPrefix + strconv.FormatUint(uint64(p), 16)
}
